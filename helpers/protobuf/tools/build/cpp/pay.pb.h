// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pay.proto

#ifndef PROTOBUF_pay_2eproto__INCLUDED
#define PROTOBUF_pay_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace ts {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_pay_2eproto();
void protobuf_AssignDesc_pay_2eproto();
void protobuf_ShutdownFile_pay_2eproto();

class PayInfo;
class Price;
class Profit;
class ProfitInfo;
class SubAcctInfo;
class AcctInfo;

// ===================================================================

class PayInfo : public ::google::protobuf::Message {
 public:
  PayInfo();
  virtual ~PayInfo();

  PayInfo(const PayInfo& from);

  inline PayInfo& operator=(const PayInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PayInfo& default_instance();

  void Swap(PayInfo* other);

  // implements Message ----------------------------------------------

  PayInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PayInfo& from);
  void MergeFrom(const PayInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 paytype = 1;
  inline bool has_paytype() const;
  inline void clear_paytype();
  static const int kPaytypeFieldNumber = 1;
  inline ::google::protobuf::int32 paytype() const;
  inline void set_paytype(::google::protobuf::int32 value);

  // required int32 channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional int64 tranamt = 3;
  inline bool has_tranamt() const;
  inline void clear_tranamt();
  static const int kTranamtFieldNumber = 3;
  inline ::google::protobuf::int64 tranamt() const;
  inline void set_tranamt(::google::protobuf::int64 value);

  // optional int64 remainamt = 4;
  inline bool has_remainamt() const;
  inline void clear_remainamt();
  static const int kRemainamtFieldNumber = 4;
  inline ::google::protobuf::int64 remainamt() const;
  inline void set_remainamt(::google::protobuf::int64 value);

  // optional string remark = 5;
  inline bool has_remark() const;
  inline void clear_remark();
  static const int kRemarkFieldNumber = 5;
  inline const ::std::string& remark() const;
  inline void set_remark(const ::std::string& value);
  inline void set_remark(const char* value);
  inline void set_remark(const char* value, size_t size);
  inline ::std::string* mutable_remark();
  inline ::std::string* release_remark();
  inline void set_allocated_remark(::std::string* remark);

  // optional string subcmd = 6;
  inline bool has_subcmd() const;
  inline void clear_subcmd();
  static const int kSubcmdFieldNumber = 6;
  inline const ::std::string& subcmd() const;
  inline void set_subcmd(const ::std::string& value);
  inline void set_subcmd(const char* value);
  inline void set_subcmd(const char* value, size_t size);
  inline ::std::string* mutable_subcmd();
  inline ::std::string* release_subcmd();
  inline void set_allocated_subcmd(::std::string* subcmd);

  // @@protoc_insertion_point(class_scope:ts.PayInfo)
 private:
  inline void set_has_paytype();
  inline void clear_has_paytype();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_tranamt();
  inline void clear_has_tranamt();
  inline void set_has_remainamt();
  inline void clear_has_remainamt();
  inline void set_has_remark();
  inline void clear_has_remark();
  inline void set_has_subcmd();
  inline void clear_has_subcmd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 paytype_;
  ::google::protobuf::int32 channel_;
  ::google::protobuf::int64 tranamt_;
  ::google::protobuf::int64 remainamt_;
  ::std::string* remark_;
  ::std::string* subcmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_pay_2eproto();
  friend void protobuf_AssignDesc_pay_2eproto();
  friend void protobuf_ShutdownFile_pay_2eproto();

  void InitAsDefaultInstance();
  static PayInfo* default_instance_;
};
// -------------------------------------------------------------------

class Price : public ::google::protobuf::Message {
 public:
  Price();
  virtual ~Price();

  Price(const Price& from);

  inline Price& operator=(const Price& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Price& default_instance();

  void Swap(Price* other);

  // implements Message ----------------------------------------------

  Price* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Price& from);
  void MergeFrom(const Price& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string dealer = 1;
  inline bool has_dealer() const;
  inline void clear_dealer();
  static const int kDealerFieldNumber = 1;
  inline const ::std::string& dealer() const;
  inline void set_dealer(const ::std::string& value);
  inline void set_dealer(const char* value);
  inline void set_dealer(const char* value, size_t size);
  inline ::std::string* mutable_dealer();
  inline ::std::string* release_dealer();
  inline void set_allocated_dealer(::std::string* dealer);

  // required int64 amt = 2;
  inline bool has_amt() const;
  inline void clear_amt();
  static const int kAmtFieldNumber = 2;
  inline ::google::protobuf::int64 amt() const;
  inline void set_amt(::google::protobuf::int64 value);

  // optional string acctid = 3;
  inline bool has_acctid() const;
  inline void clear_acctid();
  static const int kAcctidFieldNumber = 3;
  inline const ::std::string& acctid() const;
  inline void set_acctid(const ::std::string& value);
  inline void set_acctid(const char* value);
  inline void set_acctid(const char* value, size_t size);
  inline ::std::string* mutable_acctid();
  inline ::std::string* release_acctid();
  inline void set_allocated_acctid(::std::string* acctid);

  // optional int64 channel = 4;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 4;
  inline ::google::protobuf::int64 channel() const;
  inline void set_channel(::google::protobuf::int64 value);

  // optional int64 secretprice = 5;
  inline bool has_secretprice() const;
  inline void clear_secretprice();
  static const int kSecretpriceFieldNumber = 5;
  inline ::google::protobuf::int64 secretprice() const;
  inline void set_secretprice(::google::protobuf::int64 value);

  // optional string ruleid = 6;
  inline bool has_ruleid() const;
  inline void clear_ruleid();
  static const int kRuleidFieldNumber = 6;
  inline const ::std::string& ruleid() const;
  inline void set_ruleid(const ::std::string& value);
  inline void set_ruleid(const char* value);
  inline void set_ruleid(const char* value, size_t size);
  inline ::std::string* mutable_ruleid();
  inline ::std::string* release_ruleid();
  inline void set_allocated_ruleid(::std::string* ruleid);

  // optional int64 profit = 7;
  inline bool has_profit() const;
  inline void clear_profit();
  static const int kProfitFieldNumber = 7;
  inline ::google::protobuf::int64 profit() const;
  inline void set_profit(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ts.Price)
 private:
  inline void set_has_dealer();
  inline void clear_has_dealer();
  inline void set_has_amt();
  inline void clear_has_amt();
  inline void set_has_acctid();
  inline void clear_has_acctid();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_secretprice();
  inline void clear_has_secretprice();
  inline void set_has_ruleid();
  inline void clear_has_ruleid();
  inline void set_has_profit();
  inline void clear_has_profit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* dealer_;
  ::google::protobuf::int64 amt_;
  ::std::string* acctid_;
  ::google::protobuf::int64 channel_;
  ::google::protobuf::int64 secretprice_;
  ::std::string* ruleid_;
  ::google::protobuf::int64 profit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_pay_2eproto();
  friend void protobuf_AssignDesc_pay_2eproto();
  friend void protobuf_ShutdownFile_pay_2eproto();

  void InitAsDefaultInstance();
  static Price* default_instance_;
};
// -------------------------------------------------------------------

class Profit : public ::google::protobuf::Message {
 public:
  Profit();
  virtual ~Profit();

  Profit(const Profit& from);

  inline Profit& operator=(const Profit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Profit& default_instance();

  void Swap(Profit* other);

  // implements Message ----------------------------------------------

  Profit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Profit& from);
  void MergeFrom(const Profit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string dealer = 1;
  inline bool has_dealer() const;
  inline void clear_dealer();
  static const int kDealerFieldNumber = 1;
  inline const ::std::string& dealer() const;
  inline void set_dealer(const ::std::string& value);
  inline void set_dealer(const char* value);
  inline void set_dealer(const char* value, size_t size);
  inline ::std::string* mutable_dealer();
  inline ::std::string* release_dealer();
  inline void set_allocated_dealer(::std::string* dealer);

  // required string acctid = 2;
  inline bool has_acctid() const;
  inline void clear_acctid();
  static const int kAcctidFieldNumber = 2;
  inline const ::std::string& acctid() const;
  inline void set_acctid(const ::std::string& value);
  inline void set_acctid(const char* value);
  inline void set_acctid(const char* value, size_t size);
  inline ::std::string* mutable_acctid();
  inline ::std::string* release_acctid();
  inline void set_allocated_acctid(::std::string* acctid);

  // optional int64 saleamt = 3;
  inline bool has_saleamt() const;
  inline void clear_saleamt();
  static const int kSaleamtFieldNumber = 3;
  inline ::google::protobuf::int64 saleamt() const;
  inline void set_saleamt(::google::protobuf::int64 value);

  // optional int64 profit = 4;
  inline bool has_profit() const;
  inline void clear_profit();
  static const int kProfitFieldNumber = 4;
  inline ::google::protobuf::int64 profit() const;
  inline void set_profit(::google::protobuf::int64 value);

  // optional int64 shouldpay = 5;
  inline bool has_shouldpay() const;
  inline void clear_shouldpay();
  static const int kShouldpayFieldNumber = 5;
  inline ::google::protobuf::int64 shouldpay() const;
  inline void set_shouldpay(::google::protobuf::int64 value);

  // optional int32 scrtprice = 6;
  inline bool has_scrtprice() const;
  inline void clear_scrtprice();
  static const int kScrtpriceFieldNumber = 6;
  inline ::google::protobuf::int32 scrtprice() const;
  inline void set_scrtprice(::google::protobuf::int32 value);

  // optional string ruleid = 7;
  inline bool has_ruleid() const;
  inline void clear_ruleid();
  static const int kRuleidFieldNumber = 7;
  inline const ::std::string& ruleid() const;
  inline void set_ruleid(const ::std::string& value);
  inline void set_ruleid(const char* value);
  inline void set_ruleid(const char* value, size_t size);
  inline ::std::string* mutable_ruleid();
  inline ::std::string* release_ruleid();
  inline void set_allocated_ruleid(::std::string* ruleid);

  // optional string param = 8;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 8;
  inline const ::std::string& param() const;
  inline void set_param(const ::std::string& value);
  inline void set_param(const char* value);
  inline void set_param(const char* value, size_t size);
  inline ::std::string* mutable_param();
  inline ::std::string* release_param();
  inline void set_allocated_param(::std::string* param);

  // optional string groupid = 9;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupidFieldNumber = 9;
  inline const ::std::string& groupid() const;
  inline void set_groupid(const ::std::string& value);
  inline void set_groupid(const char* value);
  inline void set_groupid(const char* value, size_t size);
  inline ::std::string* mutable_groupid();
  inline ::std::string* release_groupid();
  inline void set_allocated_groupid(::std::string* groupid);

  // @@protoc_insertion_point(class_scope:ts.Profit)
 private:
  inline void set_has_dealer();
  inline void clear_has_dealer();
  inline void set_has_acctid();
  inline void clear_has_acctid();
  inline void set_has_saleamt();
  inline void clear_has_saleamt();
  inline void set_has_profit();
  inline void clear_has_profit();
  inline void set_has_shouldpay();
  inline void clear_has_shouldpay();
  inline void set_has_scrtprice();
  inline void clear_has_scrtprice();
  inline void set_has_ruleid();
  inline void clear_has_ruleid();
  inline void set_has_param();
  inline void clear_has_param();
  inline void set_has_groupid();
  inline void clear_has_groupid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* dealer_;
  ::std::string* acctid_;
  ::google::protobuf::int64 saleamt_;
  ::google::protobuf::int64 profit_;
  ::google::protobuf::int64 shouldpay_;
  ::std::string* ruleid_;
  ::std::string* param_;
  ::std::string* groupid_;
  ::google::protobuf::int32 scrtprice_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_pay_2eproto();
  friend void protobuf_AssignDesc_pay_2eproto();
  friend void protobuf_ShutdownFile_pay_2eproto();

  void InitAsDefaultInstance();
  static Profit* default_instance_;
};
// -------------------------------------------------------------------

class ProfitInfo : public ::google::protobuf::Message {
 public:
  ProfitInfo();
  virtual ~ProfitInfo();

  ProfitInfo(const ProfitInfo& from);

  inline ProfitInfo& operator=(const ProfitInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProfitInfo& default_instance();

  void Swap(ProfitInfo* other);

  // implements Message ----------------------------------------------

  ProfitInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProfitInfo& from);
  void MergeFrom(const ProfitInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string productid = 1;
  inline bool has_productid() const;
  inline void clear_productid();
  static const int kProductidFieldNumber = 1;
  inline const ::std::string& productid() const;
  inline void set_productid(const ::std::string& value);
  inline void set_productid(const char* value);
  inline void set_productid(const char* value, size_t size);
  inline ::std::string* mutable_productid();
  inline ::std::string* release_productid();
  inline void set_allocated_productid(::std::string* productid);

  // optional int64 srcamt = 2;
  inline bool has_srcamt() const;
  inline void clear_srcamt();
  static const int kSrcamtFieldNumber = 2;
  inline ::google::protobuf::int64 srcamt() const;
  inline void set_srcamt(::google::protobuf::int64 value);

  // optional int64 saleamt = 3;
  inline bool has_saleamt() const;
  inline void clear_saleamt();
  static const int kSaleamtFieldNumber = 3;
  inline ::google::protobuf::int64 saleamt() const;
  inline void set_saleamt(::google::protobuf::int64 value);

  // optional int64 totalprofit = 4;
  inline bool has_totalprofit() const;
  inline void clear_totalprofit();
  static const int kTotalprofitFieldNumber = 4;
  inline ::google::protobuf::int64 totalprofit() const;
  inline void set_totalprofit(::google::protobuf::int64 value);

  // repeated .ts.Profit profitlist = 5;
  inline int profitlist_size() const;
  inline void clear_profitlist();
  static const int kProfitlistFieldNumber = 5;
  inline const ::ts::Profit& profitlist(int index) const;
  inline ::ts::Profit* mutable_profitlist(int index);
  inline ::ts::Profit* add_profitlist();
  inline const ::google::protobuf::RepeatedPtrField< ::ts::Profit >&
      profitlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ts::Profit >*
      mutable_profitlist();

  // @@protoc_insertion_point(class_scope:ts.ProfitInfo)
 private:
  inline void set_has_productid();
  inline void clear_has_productid();
  inline void set_has_srcamt();
  inline void clear_has_srcamt();
  inline void set_has_saleamt();
  inline void clear_has_saleamt();
  inline void set_has_totalprofit();
  inline void clear_has_totalprofit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* productid_;
  ::google::protobuf::int64 srcamt_;
  ::google::protobuf::int64 saleamt_;
  ::google::protobuf::int64 totalprofit_;
  ::google::protobuf::RepeatedPtrField< ::ts::Profit > profitlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_pay_2eproto();
  friend void protobuf_AssignDesc_pay_2eproto();
  friend void protobuf_ShutdownFile_pay_2eproto();

  void InitAsDefaultInstance();
  static ProfitInfo* default_instance_;
};
// -------------------------------------------------------------------

class SubAcctInfo : public ::google::protobuf::Message {
 public:
  SubAcctInfo();
  virtual ~SubAcctInfo();

  SubAcctInfo(const SubAcctInfo& from);

  inline SubAcctInfo& operator=(const SubAcctInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubAcctInfo& default_instance();

  void Swap(SubAcctInfo* other);

  // implements Message ----------------------------------------------

  SubAcctInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubAcctInfo& from);
  void MergeFrom(const SubAcctInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string subacctid = 1;
  inline bool has_subacctid() const;
  inline void clear_subacctid();
  static const int kSubacctidFieldNumber = 1;
  inline const ::std::string& subacctid() const;
  inline void set_subacctid(const ::std::string& value);
  inline void set_subacctid(const char* value);
  inline void set_subacctid(const char* value, size_t size);
  inline ::std::string* mutable_subacctid();
  inline ::std::string* release_subacctid();
  inline void set_allocated_subacctid(::std::string* subacctid);

  // optional int64 amt = 2;
  inline bool has_amt() const;
  inline void clear_amt();
  static const int kAmtFieldNumber = 2;
  inline ::google::protobuf::int64 amt() const;
  inline void set_amt(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ts.SubAcctInfo)
 private:
  inline void set_has_subacctid();
  inline void clear_has_subacctid();
  inline void set_has_amt();
  inline void clear_has_amt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* subacctid_;
  ::google::protobuf::int64 amt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_pay_2eproto();
  friend void protobuf_AssignDesc_pay_2eproto();
  friend void protobuf_ShutdownFile_pay_2eproto();

  void InitAsDefaultInstance();
  static SubAcctInfo* default_instance_;
};
// -------------------------------------------------------------------

class AcctInfo : public ::google::protobuf::Message {
 public:
  AcctInfo();
  virtual ~AcctInfo();

  AcctInfo(const AcctInfo& from);

  inline AcctInfo& operator=(const AcctInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AcctInfo& default_instance();

  void Swap(AcctInfo* other);

  // implements Message ----------------------------------------------

  AcctInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AcctInfo& from);
  void MergeFrom(const AcctInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string acctid = 1;
  inline bool has_acctid() const;
  inline void clear_acctid();
  static const int kAcctidFieldNumber = 1;
  inline const ::std::string& acctid() const;
  inline void set_acctid(const ::std::string& value);
  inline void set_acctid(const char* value);
  inline void set_acctid(const char* value, size_t size);
  inline ::std::string* mutable_acctid();
  inline ::std::string* release_acctid();
  inline void set_allocated_acctid(::std::string* acctid);

  // required string dealid = 2;
  inline bool has_dealid() const;
  inline void clear_dealid();
  static const int kDealidFieldNumber = 2;
  inline const ::std::string& dealid() const;
  inline void set_dealid(const ::std::string& value);
  inline void set_dealid(const char* value);
  inline void set_dealid(const char* value, size_t size);
  inline ::std::string* mutable_dealid();
  inline ::std::string* release_dealid();
  inline void set_allocated_dealid(::std::string* dealid);

  // repeated .ts.SubAcctInfo subacct = 3;
  inline int subacct_size() const;
  inline void clear_subacct();
  static const int kSubacctFieldNumber = 3;
  inline const ::ts::SubAcctInfo& subacct(int index) const;
  inline ::ts::SubAcctInfo* mutable_subacct(int index);
  inline ::ts::SubAcctInfo* add_subacct();
  inline const ::google::protobuf::RepeatedPtrField< ::ts::SubAcctInfo >&
      subacct() const;
  inline ::google::protobuf::RepeatedPtrField< ::ts::SubAcctInfo >*
      mutable_subacct();

  // @@protoc_insertion_point(class_scope:ts.AcctInfo)
 private:
  inline void set_has_acctid();
  inline void clear_has_acctid();
  inline void set_has_dealid();
  inline void clear_has_dealid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* acctid_;
  ::std::string* dealid_;
  ::google::protobuf::RepeatedPtrField< ::ts::SubAcctInfo > subacct_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_pay_2eproto();
  friend void protobuf_AssignDesc_pay_2eproto();
  friend void protobuf_ShutdownFile_pay_2eproto();

  void InitAsDefaultInstance();
  static AcctInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// PayInfo

// required int32 paytype = 1;
inline bool PayInfo::has_paytype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PayInfo::set_has_paytype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PayInfo::clear_has_paytype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PayInfo::clear_paytype() {
  paytype_ = 0;
  clear_has_paytype();
}
inline ::google::protobuf::int32 PayInfo::paytype() const {
  return paytype_;
}
inline void PayInfo::set_paytype(::google::protobuf::int32 value) {
  set_has_paytype();
  paytype_ = value;
}

// required int32 channel = 2;
inline bool PayInfo::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PayInfo::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PayInfo::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PayInfo::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 PayInfo::channel() const {
  return channel_;
}
inline void PayInfo::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional int64 tranamt = 3;
inline bool PayInfo::has_tranamt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PayInfo::set_has_tranamt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PayInfo::clear_has_tranamt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PayInfo::clear_tranamt() {
  tranamt_ = GOOGLE_LONGLONG(0);
  clear_has_tranamt();
}
inline ::google::protobuf::int64 PayInfo::tranamt() const {
  return tranamt_;
}
inline void PayInfo::set_tranamt(::google::protobuf::int64 value) {
  set_has_tranamt();
  tranamt_ = value;
}

// optional int64 remainamt = 4;
inline bool PayInfo::has_remainamt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PayInfo::set_has_remainamt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PayInfo::clear_has_remainamt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PayInfo::clear_remainamt() {
  remainamt_ = GOOGLE_LONGLONG(0);
  clear_has_remainamt();
}
inline ::google::protobuf::int64 PayInfo::remainamt() const {
  return remainamt_;
}
inline void PayInfo::set_remainamt(::google::protobuf::int64 value) {
  set_has_remainamt();
  remainamt_ = value;
}

// optional string remark = 5;
inline bool PayInfo::has_remark() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PayInfo::set_has_remark() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PayInfo::clear_has_remark() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PayInfo::clear_remark() {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    remark_->clear();
  }
  clear_has_remark();
}
inline const ::std::string& PayInfo::remark() const {
  return *remark_;
}
inline void PayInfo::set_remark(const ::std::string& value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void PayInfo::set_remark(const char* value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void PayInfo::set_remark(const char* value, size_t size) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayInfo::mutable_remark() {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  return remark_;
}
inline ::std::string* PayInfo::release_remark() {
  clear_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remark_;
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayInfo::set_allocated_remark(::std::string* remark) {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    delete remark_;
  }
  if (remark) {
    set_has_remark();
    remark_ = remark;
  } else {
    clear_has_remark();
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string subcmd = 6;
inline bool PayInfo::has_subcmd() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PayInfo::set_has_subcmd() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PayInfo::clear_has_subcmd() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PayInfo::clear_subcmd() {
  if (subcmd_ != &::google::protobuf::internal::kEmptyString) {
    subcmd_->clear();
  }
  clear_has_subcmd();
}
inline const ::std::string& PayInfo::subcmd() const {
  return *subcmd_;
}
inline void PayInfo::set_subcmd(const ::std::string& value) {
  set_has_subcmd();
  if (subcmd_ == &::google::protobuf::internal::kEmptyString) {
    subcmd_ = new ::std::string;
  }
  subcmd_->assign(value);
}
inline void PayInfo::set_subcmd(const char* value) {
  set_has_subcmd();
  if (subcmd_ == &::google::protobuf::internal::kEmptyString) {
    subcmd_ = new ::std::string;
  }
  subcmd_->assign(value);
}
inline void PayInfo::set_subcmd(const char* value, size_t size) {
  set_has_subcmd();
  if (subcmd_ == &::google::protobuf::internal::kEmptyString) {
    subcmd_ = new ::std::string;
  }
  subcmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayInfo::mutable_subcmd() {
  set_has_subcmd();
  if (subcmd_ == &::google::protobuf::internal::kEmptyString) {
    subcmd_ = new ::std::string;
  }
  return subcmd_;
}
inline ::std::string* PayInfo::release_subcmd() {
  clear_has_subcmd();
  if (subcmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subcmd_;
    subcmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayInfo::set_allocated_subcmd(::std::string* subcmd) {
  if (subcmd_ != &::google::protobuf::internal::kEmptyString) {
    delete subcmd_;
  }
  if (subcmd) {
    set_has_subcmd();
    subcmd_ = subcmd;
  } else {
    clear_has_subcmd();
    subcmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Price

// required string dealer = 1;
inline bool Price::has_dealer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Price::set_has_dealer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Price::clear_has_dealer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Price::clear_dealer() {
  if (dealer_ != &::google::protobuf::internal::kEmptyString) {
    dealer_->clear();
  }
  clear_has_dealer();
}
inline const ::std::string& Price::dealer() const {
  return *dealer_;
}
inline void Price::set_dealer(const ::std::string& value) {
  set_has_dealer();
  if (dealer_ == &::google::protobuf::internal::kEmptyString) {
    dealer_ = new ::std::string;
  }
  dealer_->assign(value);
}
inline void Price::set_dealer(const char* value) {
  set_has_dealer();
  if (dealer_ == &::google::protobuf::internal::kEmptyString) {
    dealer_ = new ::std::string;
  }
  dealer_->assign(value);
}
inline void Price::set_dealer(const char* value, size_t size) {
  set_has_dealer();
  if (dealer_ == &::google::protobuf::internal::kEmptyString) {
    dealer_ = new ::std::string;
  }
  dealer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Price::mutable_dealer() {
  set_has_dealer();
  if (dealer_ == &::google::protobuf::internal::kEmptyString) {
    dealer_ = new ::std::string;
  }
  return dealer_;
}
inline ::std::string* Price::release_dealer() {
  clear_has_dealer();
  if (dealer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dealer_;
    dealer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Price::set_allocated_dealer(::std::string* dealer) {
  if (dealer_ != &::google::protobuf::internal::kEmptyString) {
    delete dealer_;
  }
  if (dealer) {
    set_has_dealer();
    dealer_ = dealer;
  } else {
    clear_has_dealer();
    dealer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 amt = 2;
inline bool Price::has_amt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Price::set_has_amt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Price::clear_has_amt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Price::clear_amt() {
  amt_ = GOOGLE_LONGLONG(0);
  clear_has_amt();
}
inline ::google::protobuf::int64 Price::amt() const {
  return amt_;
}
inline void Price::set_amt(::google::protobuf::int64 value) {
  set_has_amt();
  amt_ = value;
}

// optional string acctid = 3;
inline bool Price::has_acctid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Price::set_has_acctid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Price::clear_has_acctid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Price::clear_acctid() {
  if (acctid_ != &::google::protobuf::internal::kEmptyString) {
    acctid_->clear();
  }
  clear_has_acctid();
}
inline const ::std::string& Price::acctid() const {
  return *acctid_;
}
inline void Price::set_acctid(const ::std::string& value) {
  set_has_acctid();
  if (acctid_ == &::google::protobuf::internal::kEmptyString) {
    acctid_ = new ::std::string;
  }
  acctid_->assign(value);
}
inline void Price::set_acctid(const char* value) {
  set_has_acctid();
  if (acctid_ == &::google::protobuf::internal::kEmptyString) {
    acctid_ = new ::std::string;
  }
  acctid_->assign(value);
}
inline void Price::set_acctid(const char* value, size_t size) {
  set_has_acctid();
  if (acctid_ == &::google::protobuf::internal::kEmptyString) {
    acctid_ = new ::std::string;
  }
  acctid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Price::mutable_acctid() {
  set_has_acctid();
  if (acctid_ == &::google::protobuf::internal::kEmptyString) {
    acctid_ = new ::std::string;
  }
  return acctid_;
}
inline ::std::string* Price::release_acctid() {
  clear_has_acctid();
  if (acctid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = acctid_;
    acctid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Price::set_allocated_acctid(::std::string* acctid) {
  if (acctid_ != &::google::protobuf::internal::kEmptyString) {
    delete acctid_;
  }
  if (acctid) {
    set_has_acctid();
    acctid_ = acctid;
  } else {
    clear_has_acctid();
    acctid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 channel = 4;
inline bool Price::has_channel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Price::set_has_channel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Price::clear_has_channel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Price::clear_channel() {
  channel_ = GOOGLE_LONGLONG(0);
  clear_has_channel();
}
inline ::google::protobuf::int64 Price::channel() const {
  return channel_;
}
inline void Price::set_channel(::google::protobuf::int64 value) {
  set_has_channel();
  channel_ = value;
}

// optional int64 secretprice = 5;
inline bool Price::has_secretprice() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Price::set_has_secretprice() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Price::clear_has_secretprice() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Price::clear_secretprice() {
  secretprice_ = GOOGLE_LONGLONG(0);
  clear_has_secretprice();
}
inline ::google::protobuf::int64 Price::secretprice() const {
  return secretprice_;
}
inline void Price::set_secretprice(::google::protobuf::int64 value) {
  set_has_secretprice();
  secretprice_ = value;
}

// optional string ruleid = 6;
inline bool Price::has_ruleid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Price::set_has_ruleid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Price::clear_has_ruleid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Price::clear_ruleid() {
  if (ruleid_ != &::google::protobuf::internal::kEmptyString) {
    ruleid_->clear();
  }
  clear_has_ruleid();
}
inline const ::std::string& Price::ruleid() const {
  return *ruleid_;
}
inline void Price::set_ruleid(const ::std::string& value) {
  set_has_ruleid();
  if (ruleid_ == &::google::protobuf::internal::kEmptyString) {
    ruleid_ = new ::std::string;
  }
  ruleid_->assign(value);
}
inline void Price::set_ruleid(const char* value) {
  set_has_ruleid();
  if (ruleid_ == &::google::protobuf::internal::kEmptyString) {
    ruleid_ = new ::std::string;
  }
  ruleid_->assign(value);
}
inline void Price::set_ruleid(const char* value, size_t size) {
  set_has_ruleid();
  if (ruleid_ == &::google::protobuf::internal::kEmptyString) {
    ruleid_ = new ::std::string;
  }
  ruleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Price::mutable_ruleid() {
  set_has_ruleid();
  if (ruleid_ == &::google::protobuf::internal::kEmptyString) {
    ruleid_ = new ::std::string;
  }
  return ruleid_;
}
inline ::std::string* Price::release_ruleid() {
  clear_has_ruleid();
  if (ruleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ruleid_;
    ruleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Price::set_allocated_ruleid(::std::string* ruleid) {
  if (ruleid_ != &::google::protobuf::internal::kEmptyString) {
    delete ruleid_;
  }
  if (ruleid) {
    set_has_ruleid();
    ruleid_ = ruleid;
  } else {
    clear_has_ruleid();
    ruleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 profit = 7;
inline bool Price::has_profit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Price::set_has_profit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Price::clear_has_profit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Price::clear_profit() {
  profit_ = GOOGLE_LONGLONG(0);
  clear_has_profit();
}
inline ::google::protobuf::int64 Price::profit() const {
  return profit_;
}
inline void Price::set_profit(::google::protobuf::int64 value) {
  set_has_profit();
  profit_ = value;
}

// -------------------------------------------------------------------

// Profit

// required string dealer = 1;
inline bool Profit::has_dealer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Profit::set_has_dealer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Profit::clear_has_dealer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Profit::clear_dealer() {
  if (dealer_ != &::google::protobuf::internal::kEmptyString) {
    dealer_->clear();
  }
  clear_has_dealer();
}
inline const ::std::string& Profit::dealer() const {
  return *dealer_;
}
inline void Profit::set_dealer(const ::std::string& value) {
  set_has_dealer();
  if (dealer_ == &::google::protobuf::internal::kEmptyString) {
    dealer_ = new ::std::string;
  }
  dealer_->assign(value);
}
inline void Profit::set_dealer(const char* value) {
  set_has_dealer();
  if (dealer_ == &::google::protobuf::internal::kEmptyString) {
    dealer_ = new ::std::string;
  }
  dealer_->assign(value);
}
inline void Profit::set_dealer(const char* value, size_t size) {
  set_has_dealer();
  if (dealer_ == &::google::protobuf::internal::kEmptyString) {
    dealer_ = new ::std::string;
  }
  dealer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Profit::mutable_dealer() {
  set_has_dealer();
  if (dealer_ == &::google::protobuf::internal::kEmptyString) {
    dealer_ = new ::std::string;
  }
  return dealer_;
}
inline ::std::string* Profit::release_dealer() {
  clear_has_dealer();
  if (dealer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dealer_;
    dealer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Profit::set_allocated_dealer(::std::string* dealer) {
  if (dealer_ != &::google::protobuf::internal::kEmptyString) {
    delete dealer_;
  }
  if (dealer) {
    set_has_dealer();
    dealer_ = dealer;
  } else {
    clear_has_dealer();
    dealer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string acctid = 2;
inline bool Profit::has_acctid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Profit::set_has_acctid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Profit::clear_has_acctid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Profit::clear_acctid() {
  if (acctid_ != &::google::protobuf::internal::kEmptyString) {
    acctid_->clear();
  }
  clear_has_acctid();
}
inline const ::std::string& Profit::acctid() const {
  return *acctid_;
}
inline void Profit::set_acctid(const ::std::string& value) {
  set_has_acctid();
  if (acctid_ == &::google::protobuf::internal::kEmptyString) {
    acctid_ = new ::std::string;
  }
  acctid_->assign(value);
}
inline void Profit::set_acctid(const char* value) {
  set_has_acctid();
  if (acctid_ == &::google::protobuf::internal::kEmptyString) {
    acctid_ = new ::std::string;
  }
  acctid_->assign(value);
}
inline void Profit::set_acctid(const char* value, size_t size) {
  set_has_acctid();
  if (acctid_ == &::google::protobuf::internal::kEmptyString) {
    acctid_ = new ::std::string;
  }
  acctid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Profit::mutable_acctid() {
  set_has_acctid();
  if (acctid_ == &::google::protobuf::internal::kEmptyString) {
    acctid_ = new ::std::string;
  }
  return acctid_;
}
inline ::std::string* Profit::release_acctid() {
  clear_has_acctid();
  if (acctid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = acctid_;
    acctid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Profit::set_allocated_acctid(::std::string* acctid) {
  if (acctid_ != &::google::protobuf::internal::kEmptyString) {
    delete acctid_;
  }
  if (acctid) {
    set_has_acctid();
    acctid_ = acctid;
  } else {
    clear_has_acctid();
    acctid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 saleamt = 3;
inline bool Profit::has_saleamt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Profit::set_has_saleamt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Profit::clear_has_saleamt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Profit::clear_saleamt() {
  saleamt_ = GOOGLE_LONGLONG(0);
  clear_has_saleamt();
}
inline ::google::protobuf::int64 Profit::saleamt() const {
  return saleamt_;
}
inline void Profit::set_saleamt(::google::protobuf::int64 value) {
  set_has_saleamt();
  saleamt_ = value;
}

// optional int64 profit = 4;
inline bool Profit::has_profit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Profit::set_has_profit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Profit::clear_has_profit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Profit::clear_profit() {
  profit_ = GOOGLE_LONGLONG(0);
  clear_has_profit();
}
inline ::google::protobuf::int64 Profit::profit() const {
  return profit_;
}
inline void Profit::set_profit(::google::protobuf::int64 value) {
  set_has_profit();
  profit_ = value;
}

// optional int64 shouldpay = 5;
inline bool Profit::has_shouldpay() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Profit::set_has_shouldpay() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Profit::clear_has_shouldpay() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Profit::clear_shouldpay() {
  shouldpay_ = GOOGLE_LONGLONG(0);
  clear_has_shouldpay();
}
inline ::google::protobuf::int64 Profit::shouldpay() const {
  return shouldpay_;
}
inline void Profit::set_shouldpay(::google::protobuf::int64 value) {
  set_has_shouldpay();
  shouldpay_ = value;
}

// optional int32 scrtprice = 6;
inline bool Profit::has_scrtprice() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Profit::set_has_scrtprice() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Profit::clear_has_scrtprice() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Profit::clear_scrtprice() {
  scrtprice_ = 0;
  clear_has_scrtprice();
}
inline ::google::protobuf::int32 Profit::scrtprice() const {
  return scrtprice_;
}
inline void Profit::set_scrtprice(::google::protobuf::int32 value) {
  set_has_scrtprice();
  scrtprice_ = value;
}

// optional string ruleid = 7;
inline bool Profit::has_ruleid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Profit::set_has_ruleid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Profit::clear_has_ruleid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Profit::clear_ruleid() {
  if (ruleid_ != &::google::protobuf::internal::kEmptyString) {
    ruleid_->clear();
  }
  clear_has_ruleid();
}
inline const ::std::string& Profit::ruleid() const {
  return *ruleid_;
}
inline void Profit::set_ruleid(const ::std::string& value) {
  set_has_ruleid();
  if (ruleid_ == &::google::protobuf::internal::kEmptyString) {
    ruleid_ = new ::std::string;
  }
  ruleid_->assign(value);
}
inline void Profit::set_ruleid(const char* value) {
  set_has_ruleid();
  if (ruleid_ == &::google::protobuf::internal::kEmptyString) {
    ruleid_ = new ::std::string;
  }
  ruleid_->assign(value);
}
inline void Profit::set_ruleid(const char* value, size_t size) {
  set_has_ruleid();
  if (ruleid_ == &::google::protobuf::internal::kEmptyString) {
    ruleid_ = new ::std::string;
  }
  ruleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Profit::mutable_ruleid() {
  set_has_ruleid();
  if (ruleid_ == &::google::protobuf::internal::kEmptyString) {
    ruleid_ = new ::std::string;
  }
  return ruleid_;
}
inline ::std::string* Profit::release_ruleid() {
  clear_has_ruleid();
  if (ruleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ruleid_;
    ruleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Profit::set_allocated_ruleid(::std::string* ruleid) {
  if (ruleid_ != &::google::protobuf::internal::kEmptyString) {
    delete ruleid_;
  }
  if (ruleid) {
    set_has_ruleid();
    ruleid_ = ruleid;
  } else {
    clear_has_ruleid();
    ruleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string param = 8;
inline bool Profit::has_param() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Profit::set_has_param() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Profit::clear_has_param() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Profit::clear_param() {
  if (param_ != &::google::protobuf::internal::kEmptyString) {
    param_->clear();
  }
  clear_has_param();
}
inline const ::std::string& Profit::param() const {
  return *param_;
}
inline void Profit::set_param(const ::std::string& value) {
  set_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    param_ = new ::std::string;
  }
  param_->assign(value);
}
inline void Profit::set_param(const char* value) {
  set_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    param_ = new ::std::string;
  }
  param_->assign(value);
}
inline void Profit::set_param(const char* value, size_t size) {
  set_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    param_ = new ::std::string;
  }
  param_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Profit::mutable_param() {
  set_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    param_ = new ::std::string;
  }
  return param_;
}
inline ::std::string* Profit::release_param() {
  clear_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = param_;
    param_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Profit::set_allocated_param(::std::string* param) {
  if (param_ != &::google::protobuf::internal::kEmptyString) {
    delete param_;
  }
  if (param) {
    set_has_param();
    param_ = param;
  } else {
    clear_has_param();
    param_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string groupid = 9;
inline bool Profit::has_groupid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Profit::set_has_groupid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Profit::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Profit::clear_groupid() {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    groupid_->clear();
  }
  clear_has_groupid();
}
inline const ::std::string& Profit::groupid() const {
  return *groupid_;
}
inline void Profit::set_groupid(const ::std::string& value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void Profit::set_groupid(const char* value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void Profit::set_groupid(const char* value, size_t size) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Profit::mutable_groupid() {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  return groupid_;
}
inline ::std::string* Profit::release_groupid() {
  clear_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupid_;
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Profit::set_allocated_groupid(::std::string* groupid) {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    delete groupid_;
  }
  if (groupid) {
    set_has_groupid();
    groupid_ = groupid;
  } else {
    clear_has_groupid();
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ProfitInfo

// required string productid = 1;
inline bool ProfitInfo::has_productid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProfitInfo::set_has_productid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProfitInfo::clear_has_productid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProfitInfo::clear_productid() {
  if (productid_ != &::google::protobuf::internal::kEmptyString) {
    productid_->clear();
  }
  clear_has_productid();
}
inline const ::std::string& ProfitInfo::productid() const {
  return *productid_;
}
inline void ProfitInfo::set_productid(const ::std::string& value) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(value);
}
inline void ProfitInfo::set_productid(const char* value) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(value);
}
inline void ProfitInfo::set_productid(const char* value, size_t size) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProfitInfo::mutable_productid() {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  return productid_;
}
inline ::std::string* ProfitInfo::release_productid() {
  clear_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productid_;
    productid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProfitInfo::set_allocated_productid(::std::string* productid) {
  if (productid_ != &::google::protobuf::internal::kEmptyString) {
    delete productid_;
  }
  if (productid) {
    set_has_productid();
    productid_ = productid;
  } else {
    clear_has_productid();
    productid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 srcamt = 2;
inline bool ProfitInfo::has_srcamt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProfitInfo::set_has_srcamt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProfitInfo::clear_has_srcamt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProfitInfo::clear_srcamt() {
  srcamt_ = GOOGLE_LONGLONG(0);
  clear_has_srcamt();
}
inline ::google::protobuf::int64 ProfitInfo::srcamt() const {
  return srcamt_;
}
inline void ProfitInfo::set_srcamt(::google::protobuf::int64 value) {
  set_has_srcamt();
  srcamt_ = value;
}

// optional int64 saleamt = 3;
inline bool ProfitInfo::has_saleamt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProfitInfo::set_has_saleamt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProfitInfo::clear_has_saleamt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProfitInfo::clear_saleamt() {
  saleamt_ = GOOGLE_LONGLONG(0);
  clear_has_saleamt();
}
inline ::google::protobuf::int64 ProfitInfo::saleamt() const {
  return saleamt_;
}
inline void ProfitInfo::set_saleamt(::google::protobuf::int64 value) {
  set_has_saleamt();
  saleamt_ = value;
}

// optional int64 totalprofit = 4;
inline bool ProfitInfo::has_totalprofit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProfitInfo::set_has_totalprofit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProfitInfo::clear_has_totalprofit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProfitInfo::clear_totalprofit() {
  totalprofit_ = GOOGLE_LONGLONG(0);
  clear_has_totalprofit();
}
inline ::google::protobuf::int64 ProfitInfo::totalprofit() const {
  return totalprofit_;
}
inline void ProfitInfo::set_totalprofit(::google::protobuf::int64 value) {
  set_has_totalprofit();
  totalprofit_ = value;
}

// repeated .ts.Profit profitlist = 5;
inline int ProfitInfo::profitlist_size() const {
  return profitlist_.size();
}
inline void ProfitInfo::clear_profitlist() {
  profitlist_.Clear();
}
inline const ::ts::Profit& ProfitInfo::profitlist(int index) const {
  return profitlist_.Get(index);
}
inline ::ts::Profit* ProfitInfo::mutable_profitlist(int index) {
  return profitlist_.Mutable(index);
}
inline ::ts::Profit* ProfitInfo::add_profitlist() {
  return profitlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ts::Profit >&
ProfitInfo::profitlist() const {
  return profitlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ts::Profit >*
ProfitInfo::mutable_profitlist() {
  return &profitlist_;
}

// -------------------------------------------------------------------

// SubAcctInfo

// required string subacctid = 1;
inline bool SubAcctInfo::has_subacctid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubAcctInfo::set_has_subacctid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubAcctInfo::clear_has_subacctid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubAcctInfo::clear_subacctid() {
  if (subacctid_ != &::google::protobuf::internal::kEmptyString) {
    subacctid_->clear();
  }
  clear_has_subacctid();
}
inline const ::std::string& SubAcctInfo::subacctid() const {
  return *subacctid_;
}
inline void SubAcctInfo::set_subacctid(const ::std::string& value) {
  set_has_subacctid();
  if (subacctid_ == &::google::protobuf::internal::kEmptyString) {
    subacctid_ = new ::std::string;
  }
  subacctid_->assign(value);
}
inline void SubAcctInfo::set_subacctid(const char* value) {
  set_has_subacctid();
  if (subacctid_ == &::google::protobuf::internal::kEmptyString) {
    subacctid_ = new ::std::string;
  }
  subacctid_->assign(value);
}
inline void SubAcctInfo::set_subacctid(const char* value, size_t size) {
  set_has_subacctid();
  if (subacctid_ == &::google::protobuf::internal::kEmptyString) {
    subacctid_ = new ::std::string;
  }
  subacctid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SubAcctInfo::mutable_subacctid() {
  set_has_subacctid();
  if (subacctid_ == &::google::protobuf::internal::kEmptyString) {
    subacctid_ = new ::std::string;
  }
  return subacctid_;
}
inline ::std::string* SubAcctInfo::release_subacctid() {
  clear_has_subacctid();
  if (subacctid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subacctid_;
    subacctid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SubAcctInfo::set_allocated_subacctid(::std::string* subacctid) {
  if (subacctid_ != &::google::protobuf::internal::kEmptyString) {
    delete subacctid_;
  }
  if (subacctid) {
    set_has_subacctid();
    subacctid_ = subacctid;
  } else {
    clear_has_subacctid();
    subacctid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 amt = 2;
inline bool SubAcctInfo::has_amt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubAcctInfo::set_has_amt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubAcctInfo::clear_has_amt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubAcctInfo::clear_amt() {
  amt_ = GOOGLE_LONGLONG(0);
  clear_has_amt();
}
inline ::google::protobuf::int64 SubAcctInfo::amt() const {
  return amt_;
}
inline void SubAcctInfo::set_amt(::google::protobuf::int64 value) {
  set_has_amt();
  amt_ = value;
}

// -------------------------------------------------------------------

// AcctInfo

// required string acctid = 1;
inline bool AcctInfo::has_acctid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AcctInfo::set_has_acctid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AcctInfo::clear_has_acctid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AcctInfo::clear_acctid() {
  if (acctid_ != &::google::protobuf::internal::kEmptyString) {
    acctid_->clear();
  }
  clear_has_acctid();
}
inline const ::std::string& AcctInfo::acctid() const {
  return *acctid_;
}
inline void AcctInfo::set_acctid(const ::std::string& value) {
  set_has_acctid();
  if (acctid_ == &::google::protobuf::internal::kEmptyString) {
    acctid_ = new ::std::string;
  }
  acctid_->assign(value);
}
inline void AcctInfo::set_acctid(const char* value) {
  set_has_acctid();
  if (acctid_ == &::google::protobuf::internal::kEmptyString) {
    acctid_ = new ::std::string;
  }
  acctid_->assign(value);
}
inline void AcctInfo::set_acctid(const char* value, size_t size) {
  set_has_acctid();
  if (acctid_ == &::google::protobuf::internal::kEmptyString) {
    acctid_ = new ::std::string;
  }
  acctid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AcctInfo::mutable_acctid() {
  set_has_acctid();
  if (acctid_ == &::google::protobuf::internal::kEmptyString) {
    acctid_ = new ::std::string;
  }
  return acctid_;
}
inline ::std::string* AcctInfo::release_acctid() {
  clear_has_acctid();
  if (acctid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = acctid_;
    acctid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AcctInfo::set_allocated_acctid(::std::string* acctid) {
  if (acctid_ != &::google::protobuf::internal::kEmptyString) {
    delete acctid_;
  }
  if (acctid) {
    set_has_acctid();
    acctid_ = acctid;
  } else {
    clear_has_acctid();
    acctid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string dealid = 2;
inline bool AcctInfo::has_dealid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AcctInfo::set_has_dealid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AcctInfo::clear_has_dealid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AcctInfo::clear_dealid() {
  if (dealid_ != &::google::protobuf::internal::kEmptyString) {
    dealid_->clear();
  }
  clear_has_dealid();
}
inline const ::std::string& AcctInfo::dealid() const {
  return *dealid_;
}
inline void AcctInfo::set_dealid(const ::std::string& value) {
  set_has_dealid();
  if (dealid_ == &::google::protobuf::internal::kEmptyString) {
    dealid_ = new ::std::string;
  }
  dealid_->assign(value);
}
inline void AcctInfo::set_dealid(const char* value) {
  set_has_dealid();
  if (dealid_ == &::google::protobuf::internal::kEmptyString) {
    dealid_ = new ::std::string;
  }
  dealid_->assign(value);
}
inline void AcctInfo::set_dealid(const char* value, size_t size) {
  set_has_dealid();
  if (dealid_ == &::google::protobuf::internal::kEmptyString) {
    dealid_ = new ::std::string;
  }
  dealid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AcctInfo::mutable_dealid() {
  set_has_dealid();
  if (dealid_ == &::google::protobuf::internal::kEmptyString) {
    dealid_ = new ::std::string;
  }
  return dealid_;
}
inline ::std::string* AcctInfo::release_dealid() {
  clear_has_dealid();
  if (dealid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dealid_;
    dealid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AcctInfo::set_allocated_dealid(::std::string* dealid) {
  if (dealid_ != &::google::protobuf::internal::kEmptyString) {
    delete dealid_;
  }
  if (dealid) {
    set_has_dealid();
    dealid_ = dealid;
  } else {
    clear_has_dealid();
    dealid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .ts.SubAcctInfo subacct = 3;
inline int AcctInfo::subacct_size() const {
  return subacct_.size();
}
inline void AcctInfo::clear_subacct() {
  subacct_.Clear();
}
inline const ::ts::SubAcctInfo& AcctInfo::subacct(int index) const {
  return subacct_.Get(index);
}
inline ::ts::SubAcctInfo* AcctInfo::mutable_subacct(int index) {
  return subacct_.Mutable(index);
}
inline ::ts::SubAcctInfo* AcctInfo::add_subacct() {
  return subacct_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ts::SubAcctInfo >&
AcctInfo::subacct() const {
  return subacct_;
}
inline ::google::protobuf::RepeatedPtrField< ::ts::SubAcctInfo >*
AcctInfo::mutable_subacct() {
  return &subacct_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ts

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pay_2eproto__INCLUDED
