// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: portal.proto

#ifndef PROTOBUF_portal_2eproto__INCLUDED
#define PROTOBUF_portal_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "head.pb.h"
#include "client.pb.h"
#include "pay.pb.h"
#include "product.pb.h"
// @@protoc_insertion_point(includes)

namespace ts {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_portal_2eproto();
void protobuf_AssignDesc_portal_2eproto();
void protobuf_ShutdownFile_portal_2eproto();

class QueryAmt;
class QueryAmtAns;
class Charge;
class ChargeAns;
class Pay;
class PayAns;
class TransAmt;
class TransAmtAns;

// ===================================================================

class QueryAmt : public ::google::protobuf::Message {
 public:
  QueryAmt();
  virtual ~QueryAmt();

  QueryAmt(const QueryAmt& from);

  inline QueryAmt& operator=(const QueryAmt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryAmt& default_instance();

  void Swap(QueryAmt* other);

  // implements Message ----------------------------------------------

  QueryAmt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryAmt& from);
  void MergeFrom(const QueryAmt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ts.ServiceHead head = 1;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 1;
  inline const ::ts::ServiceHead& head() const;
  inline ::ts::ServiceHead* mutable_head();
  inline ::ts::ServiceHead* release_head();
  inline void set_allocated_head(::ts::ServiceHead* head);

  // repeated .ts.ClientInfo client = 2;
  inline int client_size() const;
  inline void clear_client();
  static const int kClientFieldNumber = 2;
  inline const ::ts::ClientInfo& client(int index) const;
  inline ::ts::ClientInfo* mutable_client(int index);
  inline ::ts::ClientInfo* add_client();
  inline const ::google::protobuf::RepeatedPtrField< ::ts::ClientInfo >&
      client() const;
  inline ::google::protobuf::RepeatedPtrField< ::ts::ClientInfo >*
      mutable_client();

  // @@protoc_insertion_point(class_scope:ts.QueryAmt)
 private:
  inline void set_has_head();
  inline void clear_has_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ts::ServiceHead* head_;
  ::google::protobuf::RepeatedPtrField< ::ts::ClientInfo > client_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_portal_2eproto();
  friend void protobuf_AssignDesc_portal_2eproto();
  friend void protobuf_ShutdownFile_portal_2eproto();

  void InitAsDefaultInstance();
  static QueryAmt* default_instance_;
};
// -------------------------------------------------------------------

class QueryAmtAns : public ::google::protobuf::Message {
 public:
  QueryAmtAns();
  virtual ~QueryAmtAns();

  QueryAmtAns(const QueryAmtAns& from);

  inline QueryAmtAns& operator=(const QueryAmtAns& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryAmtAns& default_instance();

  void Swap(QueryAmtAns* other);

  // implements Message ----------------------------------------------

  QueryAmtAns* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryAmtAns& from);
  void MergeFrom(const QueryAmtAns& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ts.ServiceHead head = 1;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 1;
  inline const ::ts::ServiceHead& head() const;
  inline ::ts::ServiceHead* mutable_head();
  inline ::ts::ServiceHead* release_head();
  inline void set_allocated_head(::ts::ServiceHead* head);

  // repeated .ts.ClientInfo client = 2;
  inline int client_size() const;
  inline void clear_client();
  static const int kClientFieldNumber = 2;
  inline const ::ts::ClientInfo& client(int index) const;
  inline ::ts::ClientInfo* mutable_client(int index);
  inline ::ts::ClientInfo* add_client();
  inline const ::google::protobuf::RepeatedPtrField< ::ts::ClientInfo >&
      client() const;
  inline ::google::protobuf::RepeatedPtrField< ::ts::ClientInfo >*
      mutable_client();

  // repeated .ts.AcctInfo acct = 3;
  inline int acct_size() const;
  inline void clear_acct();
  static const int kAcctFieldNumber = 3;
  inline const ::ts::AcctInfo& acct(int index) const;
  inline ::ts::AcctInfo* mutable_acct(int index);
  inline ::ts::AcctInfo* add_acct();
  inline const ::google::protobuf::RepeatedPtrField< ::ts::AcctInfo >&
      acct() const;
  inline ::google::protobuf::RepeatedPtrField< ::ts::AcctInfo >*
      mutable_acct();

  // @@protoc_insertion_point(class_scope:ts.QueryAmtAns)
 private:
  inline void set_has_head();
  inline void clear_has_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ts::ServiceHead* head_;
  ::google::protobuf::RepeatedPtrField< ::ts::ClientInfo > client_;
  ::google::protobuf::RepeatedPtrField< ::ts::AcctInfo > acct_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_portal_2eproto();
  friend void protobuf_AssignDesc_portal_2eproto();
  friend void protobuf_ShutdownFile_portal_2eproto();

  void InitAsDefaultInstance();
  static QueryAmtAns* default_instance_;
};
// -------------------------------------------------------------------

class Charge : public ::google::protobuf::Message {
 public:
  Charge();
  virtual ~Charge();

  Charge(const Charge& from);

  inline Charge& operator=(const Charge& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Charge& default_instance();

  void Swap(Charge* other);

  // implements Message ----------------------------------------------

  Charge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Charge& from);
  void MergeFrom(const Charge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ts.ServiceHead head = 1;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 1;
  inline const ::ts::ServiceHead& head() const;
  inline ::ts::ServiceHead* mutable_head();
  inline ::ts::ServiceHead* release_head();
  inline void set_allocated_head(::ts::ServiceHead* head);

  // optional .ts.ClientInfo client = 2;
  inline bool has_client() const;
  inline void clear_client();
  static const int kClientFieldNumber = 2;
  inline const ::ts::ClientInfo& client() const;
  inline ::ts::ClientInfo* mutable_client();
  inline ::ts::ClientInfo* release_client();
  inline void set_allocated_client(::ts::ClientInfo* client);

  // optional .ts.PayInfo pay = 3;
  inline bool has_pay() const;
  inline void clear_pay();
  static const int kPayFieldNumber = 3;
  inline const ::ts::PayInfo& pay() const;
  inline ::ts::PayInfo* mutable_pay();
  inline ::ts::PayInfo* release_pay();
  inline void set_allocated_pay(::ts::PayInfo* pay);

  // @@protoc_insertion_point(class_scope:ts.Charge)
 private:
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_client();
  inline void clear_has_client();
  inline void set_has_pay();
  inline void clear_has_pay();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ts::ServiceHead* head_;
  ::ts::ClientInfo* client_;
  ::ts::PayInfo* pay_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_portal_2eproto();
  friend void protobuf_AssignDesc_portal_2eproto();
  friend void protobuf_ShutdownFile_portal_2eproto();

  void InitAsDefaultInstance();
  static Charge* default_instance_;
};
// -------------------------------------------------------------------

class ChargeAns : public ::google::protobuf::Message {
 public:
  ChargeAns();
  virtual ~ChargeAns();

  ChargeAns(const ChargeAns& from);

  inline ChargeAns& operator=(const ChargeAns& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChargeAns& default_instance();

  void Swap(ChargeAns* other);

  // implements Message ----------------------------------------------

  ChargeAns* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChargeAns& from);
  void MergeFrom(const ChargeAns& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ts.ServiceHead head = 1;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 1;
  inline const ::ts::ServiceHead& head() const;
  inline ::ts::ServiceHead* mutable_head();
  inline ::ts::ServiceHead* release_head();
  inline void set_allocated_head(::ts::ServiceHead* head);

  // optional .ts.ClientInfo client = 2;
  inline bool has_client() const;
  inline void clear_client();
  static const int kClientFieldNumber = 2;
  inline const ::ts::ClientInfo& client() const;
  inline ::ts::ClientInfo* mutable_client();
  inline ::ts::ClientInfo* release_client();
  inline void set_allocated_client(::ts::ClientInfo* client);

  // optional .ts.PayInfo pay = 3;
  inline bool has_pay() const;
  inline void clear_pay();
  static const int kPayFieldNumber = 3;
  inline const ::ts::PayInfo& pay() const;
  inline ::ts::PayInfo* mutable_pay();
  inline ::ts::PayInfo* release_pay();
  inline void set_allocated_pay(::ts::PayInfo* pay);

  // @@protoc_insertion_point(class_scope:ts.ChargeAns)
 private:
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_client();
  inline void clear_has_client();
  inline void set_has_pay();
  inline void clear_has_pay();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ts::ServiceHead* head_;
  ::ts::ClientInfo* client_;
  ::ts::PayInfo* pay_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_portal_2eproto();
  friend void protobuf_AssignDesc_portal_2eproto();
  friend void protobuf_ShutdownFile_portal_2eproto();

  void InitAsDefaultInstance();
  static ChargeAns* default_instance_;
};
// -------------------------------------------------------------------

class Pay : public ::google::protobuf::Message {
 public:
  Pay();
  virtual ~Pay();

  Pay(const Pay& from);

  inline Pay& operator=(const Pay& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pay& default_instance();

  void Swap(Pay* other);

  // implements Message ----------------------------------------------

  Pay* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pay& from);
  void MergeFrom(const Pay& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ts.ServiceHead head = 1;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 1;
  inline const ::ts::ServiceHead& head() const;
  inline ::ts::ServiceHead* mutable_head();
  inline ::ts::ServiceHead* release_head();
  inline void set_allocated_head(::ts::ServiceHead* head);

  // required .ts.ClientInfo client = 2;
  inline bool has_client() const;
  inline void clear_client();
  static const int kClientFieldNumber = 2;
  inline const ::ts::ClientInfo& client() const;
  inline ::ts::ClientInfo* mutable_client();
  inline ::ts::ClientInfo* release_client();
  inline void set_allocated_client(::ts::ClientInfo* client);

  // optional .ts.ProductInfo product = 3;
  inline bool has_product() const;
  inline void clear_product();
  static const int kProductFieldNumber = 3;
  inline const ::ts::ProductInfo& product() const;
  inline ::ts::ProductInfo* mutable_product();
  inline ::ts::ProductInfo* release_product();
  inline void set_allocated_product(::ts::ProductInfo* product);

  // optional .ts.PayInfo payinfo = 4;
  inline bool has_payinfo() const;
  inline void clear_payinfo();
  static const int kPayinfoFieldNumber = 4;
  inline const ::ts::PayInfo& payinfo() const;
  inline ::ts::PayInfo* mutable_payinfo();
  inline ::ts::PayInfo* release_payinfo();
  inline void set_allocated_payinfo(::ts::PayInfo* payinfo);

  // optional .ts.ProfitInfo profitinfo = 5;
  inline bool has_profitinfo() const;
  inline void clear_profitinfo();
  static const int kProfitinfoFieldNumber = 5;
  inline const ::ts::ProfitInfo& profitinfo() const;
  inline ::ts::ProfitInfo* mutable_profitinfo();
  inline ::ts::ProfitInfo* release_profitinfo();
  inline void set_allocated_profitinfo(::ts::ProfitInfo* profitinfo);

  // @@protoc_insertion_point(class_scope:ts.Pay)
 private:
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_client();
  inline void clear_has_client();
  inline void set_has_product();
  inline void clear_has_product();
  inline void set_has_payinfo();
  inline void clear_has_payinfo();
  inline void set_has_profitinfo();
  inline void clear_has_profitinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ts::ServiceHead* head_;
  ::ts::ClientInfo* client_;
  ::ts::ProductInfo* product_;
  ::ts::PayInfo* payinfo_;
  ::ts::ProfitInfo* profitinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_portal_2eproto();
  friend void protobuf_AssignDesc_portal_2eproto();
  friend void protobuf_ShutdownFile_portal_2eproto();

  void InitAsDefaultInstance();
  static Pay* default_instance_;
};
// -------------------------------------------------------------------

class PayAns : public ::google::protobuf::Message {
 public:
  PayAns();
  virtual ~PayAns();

  PayAns(const PayAns& from);

  inline PayAns& operator=(const PayAns& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PayAns& default_instance();

  void Swap(PayAns* other);

  // implements Message ----------------------------------------------

  PayAns* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PayAns& from);
  void MergeFrom(const PayAns& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ts.ServiceHead head = 1;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 1;
  inline const ::ts::ServiceHead& head() const;
  inline ::ts::ServiceHead* mutable_head();
  inline ::ts::ServiceHead* release_head();
  inline void set_allocated_head(::ts::ServiceHead* head);

  // optional .ts.ClientInfo client = 2;
  inline bool has_client() const;
  inline void clear_client();
  static const int kClientFieldNumber = 2;
  inline const ::ts::ClientInfo& client() const;
  inline ::ts::ClientInfo* mutable_client();
  inline ::ts::ClientInfo* release_client();
  inline void set_allocated_client(::ts::ClientInfo* client);

  // optional .ts.ProductInfo product = 3;
  inline bool has_product() const;
  inline void clear_product();
  static const int kProductFieldNumber = 3;
  inline const ::ts::ProductInfo& product() const;
  inline ::ts::ProductInfo* mutable_product();
  inline ::ts::ProductInfo* release_product();
  inline void set_allocated_product(::ts::ProductInfo* product);

  // optional .ts.PayInfo payinfo = 4;
  inline bool has_payinfo() const;
  inline void clear_payinfo();
  static const int kPayinfoFieldNumber = 4;
  inline const ::ts::PayInfo& payinfo() const;
  inline ::ts::PayInfo* mutable_payinfo();
  inline ::ts::PayInfo* release_payinfo();
  inline void set_allocated_payinfo(::ts::PayInfo* payinfo);

  // @@protoc_insertion_point(class_scope:ts.PayAns)
 private:
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_client();
  inline void clear_has_client();
  inline void set_has_product();
  inline void clear_has_product();
  inline void set_has_payinfo();
  inline void clear_has_payinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ts::ServiceHead* head_;
  ::ts::ClientInfo* client_;
  ::ts::ProductInfo* product_;
  ::ts::PayInfo* payinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_portal_2eproto();
  friend void protobuf_AssignDesc_portal_2eproto();
  friend void protobuf_ShutdownFile_portal_2eproto();

  void InitAsDefaultInstance();
  static PayAns* default_instance_;
};
// -------------------------------------------------------------------

class TransAmt : public ::google::protobuf::Message {
 public:
  TransAmt();
  virtual ~TransAmt();

  TransAmt(const TransAmt& from);

  inline TransAmt& operator=(const TransAmt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransAmt& default_instance();

  void Swap(TransAmt* other);

  // implements Message ----------------------------------------------

  TransAmt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransAmt& from);
  void MergeFrom(const TransAmt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ts.ServiceHead head = 1;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 1;
  inline const ::ts::ServiceHead& head() const;
  inline ::ts::ServiceHead* mutable_head();
  inline ::ts::ServiceHead* release_head();
  inline void set_allocated_head(::ts::ServiceHead* head);

  // optional .ts.ClientInfo from_client = 2;
  inline bool has_from_client() const;
  inline void clear_from_client();
  static const int kFromClientFieldNumber = 2;
  inline const ::ts::ClientInfo& from_client() const;
  inline ::ts::ClientInfo* mutable_from_client();
  inline ::ts::ClientInfo* release_from_client();
  inline void set_allocated_from_client(::ts::ClientInfo* from_client);

  // optional .ts.ClientInfo to_client = 3;
  inline bool has_to_client() const;
  inline void clear_to_client();
  static const int kToClientFieldNumber = 3;
  inline const ::ts::ClientInfo& to_client() const;
  inline ::ts::ClientInfo* mutable_to_client();
  inline ::ts::ClientInfo* release_to_client();
  inline void set_allocated_to_client(::ts::ClientInfo* to_client);

  // optional .ts.PayInfo pay_info = 4;
  inline bool has_pay_info() const;
  inline void clear_pay_info();
  static const int kPayInfoFieldNumber = 4;
  inline const ::ts::PayInfo& pay_info() const;
  inline ::ts::PayInfo* mutable_pay_info();
  inline ::ts::PayInfo* release_pay_info();
  inline void set_allocated_pay_info(::ts::PayInfo* pay_info);

  // @@protoc_insertion_point(class_scope:ts.TransAmt)
 private:
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_from_client();
  inline void clear_has_from_client();
  inline void set_has_to_client();
  inline void clear_has_to_client();
  inline void set_has_pay_info();
  inline void clear_has_pay_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ts::ServiceHead* head_;
  ::ts::ClientInfo* from_client_;
  ::ts::ClientInfo* to_client_;
  ::ts::PayInfo* pay_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_portal_2eproto();
  friend void protobuf_AssignDesc_portal_2eproto();
  friend void protobuf_ShutdownFile_portal_2eproto();

  void InitAsDefaultInstance();
  static TransAmt* default_instance_;
};
// -------------------------------------------------------------------

class TransAmtAns : public ::google::protobuf::Message {
 public:
  TransAmtAns();
  virtual ~TransAmtAns();

  TransAmtAns(const TransAmtAns& from);

  inline TransAmtAns& operator=(const TransAmtAns& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransAmtAns& default_instance();

  void Swap(TransAmtAns* other);

  // implements Message ----------------------------------------------

  TransAmtAns* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransAmtAns& from);
  void MergeFrom(const TransAmtAns& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ts.ServiceHead head = 1;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 1;
  inline const ::ts::ServiceHead& head() const;
  inline ::ts::ServiceHead* mutable_head();
  inline ::ts::ServiceHead* release_head();
  inline void set_allocated_head(::ts::ServiceHead* head);

  // optional .ts.ClientInfo from_client = 2;
  inline bool has_from_client() const;
  inline void clear_from_client();
  static const int kFromClientFieldNumber = 2;
  inline const ::ts::ClientInfo& from_client() const;
  inline ::ts::ClientInfo* mutable_from_client();
  inline ::ts::ClientInfo* release_from_client();
  inline void set_allocated_from_client(::ts::ClientInfo* from_client);

  // optional .ts.ClientInfo to_client = 3;
  inline bool has_to_client() const;
  inline void clear_to_client();
  static const int kToClientFieldNumber = 3;
  inline const ::ts::ClientInfo& to_client() const;
  inline ::ts::ClientInfo* mutable_to_client();
  inline ::ts::ClientInfo* release_to_client();
  inline void set_allocated_to_client(::ts::ClientInfo* to_client);

  // optional .ts.PayInfo payinfo = 4;
  inline bool has_payinfo() const;
  inline void clear_payinfo();
  static const int kPayinfoFieldNumber = 4;
  inline const ::ts::PayInfo& payinfo() const;
  inline ::ts::PayInfo* mutable_payinfo();
  inline ::ts::PayInfo* release_payinfo();
  inline void set_allocated_payinfo(::ts::PayInfo* payinfo);

  // @@protoc_insertion_point(class_scope:ts.TransAmtAns)
 private:
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_from_client();
  inline void clear_has_from_client();
  inline void set_has_to_client();
  inline void clear_has_to_client();
  inline void set_has_payinfo();
  inline void clear_has_payinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ts::ServiceHead* head_;
  ::ts::ClientInfo* from_client_;
  ::ts::ClientInfo* to_client_;
  ::ts::PayInfo* payinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_portal_2eproto();
  friend void protobuf_AssignDesc_portal_2eproto();
  friend void protobuf_ShutdownFile_portal_2eproto();

  void InitAsDefaultInstance();
  static TransAmtAns* default_instance_;
};
// ===================================================================


// ===================================================================

// QueryAmt

// required .ts.ServiceHead head = 1;
inline bool QueryAmt::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryAmt::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryAmt::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryAmt::clear_head() {
  if (head_ != NULL) head_->::ts::ServiceHead::Clear();
  clear_has_head();
}
inline const ::ts::ServiceHead& QueryAmt::head() const {
  return head_ != NULL ? *head_ : *default_instance_->head_;
}
inline ::ts::ServiceHead* QueryAmt::mutable_head() {
  set_has_head();
  if (head_ == NULL) head_ = new ::ts::ServiceHead;
  return head_;
}
inline ::ts::ServiceHead* QueryAmt::release_head() {
  clear_has_head();
  ::ts::ServiceHead* temp = head_;
  head_ = NULL;
  return temp;
}
inline void QueryAmt::set_allocated_head(::ts::ServiceHead* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
}

// repeated .ts.ClientInfo client = 2;
inline int QueryAmt::client_size() const {
  return client_.size();
}
inline void QueryAmt::clear_client() {
  client_.Clear();
}
inline const ::ts::ClientInfo& QueryAmt::client(int index) const {
  return client_.Get(index);
}
inline ::ts::ClientInfo* QueryAmt::mutable_client(int index) {
  return client_.Mutable(index);
}
inline ::ts::ClientInfo* QueryAmt::add_client() {
  return client_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ts::ClientInfo >&
QueryAmt::client() const {
  return client_;
}
inline ::google::protobuf::RepeatedPtrField< ::ts::ClientInfo >*
QueryAmt::mutable_client() {
  return &client_;
}

// -------------------------------------------------------------------

// QueryAmtAns

// required .ts.ServiceHead head = 1;
inline bool QueryAmtAns::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryAmtAns::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryAmtAns::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryAmtAns::clear_head() {
  if (head_ != NULL) head_->::ts::ServiceHead::Clear();
  clear_has_head();
}
inline const ::ts::ServiceHead& QueryAmtAns::head() const {
  return head_ != NULL ? *head_ : *default_instance_->head_;
}
inline ::ts::ServiceHead* QueryAmtAns::mutable_head() {
  set_has_head();
  if (head_ == NULL) head_ = new ::ts::ServiceHead;
  return head_;
}
inline ::ts::ServiceHead* QueryAmtAns::release_head() {
  clear_has_head();
  ::ts::ServiceHead* temp = head_;
  head_ = NULL;
  return temp;
}
inline void QueryAmtAns::set_allocated_head(::ts::ServiceHead* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
}

// repeated .ts.ClientInfo client = 2;
inline int QueryAmtAns::client_size() const {
  return client_.size();
}
inline void QueryAmtAns::clear_client() {
  client_.Clear();
}
inline const ::ts::ClientInfo& QueryAmtAns::client(int index) const {
  return client_.Get(index);
}
inline ::ts::ClientInfo* QueryAmtAns::mutable_client(int index) {
  return client_.Mutable(index);
}
inline ::ts::ClientInfo* QueryAmtAns::add_client() {
  return client_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ts::ClientInfo >&
QueryAmtAns::client() const {
  return client_;
}
inline ::google::protobuf::RepeatedPtrField< ::ts::ClientInfo >*
QueryAmtAns::mutable_client() {
  return &client_;
}

// repeated .ts.AcctInfo acct = 3;
inline int QueryAmtAns::acct_size() const {
  return acct_.size();
}
inline void QueryAmtAns::clear_acct() {
  acct_.Clear();
}
inline const ::ts::AcctInfo& QueryAmtAns::acct(int index) const {
  return acct_.Get(index);
}
inline ::ts::AcctInfo* QueryAmtAns::mutable_acct(int index) {
  return acct_.Mutable(index);
}
inline ::ts::AcctInfo* QueryAmtAns::add_acct() {
  return acct_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ts::AcctInfo >&
QueryAmtAns::acct() const {
  return acct_;
}
inline ::google::protobuf::RepeatedPtrField< ::ts::AcctInfo >*
QueryAmtAns::mutable_acct() {
  return &acct_;
}

// -------------------------------------------------------------------

// Charge

// required .ts.ServiceHead head = 1;
inline bool Charge::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Charge::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Charge::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Charge::clear_head() {
  if (head_ != NULL) head_->::ts::ServiceHead::Clear();
  clear_has_head();
}
inline const ::ts::ServiceHead& Charge::head() const {
  return head_ != NULL ? *head_ : *default_instance_->head_;
}
inline ::ts::ServiceHead* Charge::mutable_head() {
  set_has_head();
  if (head_ == NULL) head_ = new ::ts::ServiceHead;
  return head_;
}
inline ::ts::ServiceHead* Charge::release_head() {
  clear_has_head();
  ::ts::ServiceHead* temp = head_;
  head_ = NULL;
  return temp;
}
inline void Charge::set_allocated_head(::ts::ServiceHead* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
}

// optional .ts.ClientInfo client = 2;
inline bool Charge::has_client() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Charge::set_has_client() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Charge::clear_has_client() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Charge::clear_client() {
  if (client_ != NULL) client_->::ts::ClientInfo::Clear();
  clear_has_client();
}
inline const ::ts::ClientInfo& Charge::client() const {
  return client_ != NULL ? *client_ : *default_instance_->client_;
}
inline ::ts::ClientInfo* Charge::mutable_client() {
  set_has_client();
  if (client_ == NULL) client_ = new ::ts::ClientInfo;
  return client_;
}
inline ::ts::ClientInfo* Charge::release_client() {
  clear_has_client();
  ::ts::ClientInfo* temp = client_;
  client_ = NULL;
  return temp;
}
inline void Charge::set_allocated_client(::ts::ClientInfo* client) {
  delete client_;
  client_ = client;
  if (client) {
    set_has_client();
  } else {
    clear_has_client();
  }
}

// optional .ts.PayInfo pay = 3;
inline bool Charge::has_pay() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Charge::set_has_pay() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Charge::clear_has_pay() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Charge::clear_pay() {
  if (pay_ != NULL) pay_->::ts::PayInfo::Clear();
  clear_has_pay();
}
inline const ::ts::PayInfo& Charge::pay() const {
  return pay_ != NULL ? *pay_ : *default_instance_->pay_;
}
inline ::ts::PayInfo* Charge::mutable_pay() {
  set_has_pay();
  if (pay_ == NULL) pay_ = new ::ts::PayInfo;
  return pay_;
}
inline ::ts::PayInfo* Charge::release_pay() {
  clear_has_pay();
  ::ts::PayInfo* temp = pay_;
  pay_ = NULL;
  return temp;
}
inline void Charge::set_allocated_pay(::ts::PayInfo* pay) {
  delete pay_;
  pay_ = pay;
  if (pay) {
    set_has_pay();
  } else {
    clear_has_pay();
  }
}

// -------------------------------------------------------------------

// ChargeAns

// required .ts.ServiceHead head = 1;
inline bool ChargeAns::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChargeAns::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChargeAns::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChargeAns::clear_head() {
  if (head_ != NULL) head_->::ts::ServiceHead::Clear();
  clear_has_head();
}
inline const ::ts::ServiceHead& ChargeAns::head() const {
  return head_ != NULL ? *head_ : *default_instance_->head_;
}
inline ::ts::ServiceHead* ChargeAns::mutable_head() {
  set_has_head();
  if (head_ == NULL) head_ = new ::ts::ServiceHead;
  return head_;
}
inline ::ts::ServiceHead* ChargeAns::release_head() {
  clear_has_head();
  ::ts::ServiceHead* temp = head_;
  head_ = NULL;
  return temp;
}
inline void ChargeAns::set_allocated_head(::ts::ServiceHead* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
}

// optional .ts.ClientInfo client = 2;
inline bool ChargeAns::has_client() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChargeAns::set_has_client() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChargeAns::clear_has_client() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChargeAns::clear_client() {
  if (client_ != NULL) client_->::ts::ClientInfo::Clear();
  clear_has_client();
}
inline const ::ts::ClientInfo& ChargeAns::client() const {
  return client_ != NULL ? *client_ : *default_instance_->client_;
}
inline ::ts::ClientInfo* ChargeAns::mutable_client() {
  set_has_client();
  if (client_ == NULL) client_ = new ::ts::ClientInfo;
  return client_;
}
inline ::ts::ClientInfo* ChargeAns::release_client() {
  clear_has_client();
  ::ts::ClientInfo* temp = client_;
  client_ = NULL;
  return temp;
}
inline void ChargeAns::set_allocated_client(::ts::ClientInfo* client) {
  delete client_;
  client_ = client;
  if (client) {
    set_has_client();
  } else {
    clear_has_client();
  }
}

// optional .ts.PayInfo pay = 3;
inline bool ChargeAns::has_pay() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChargeAns::set_has_pay() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChargeAns::clear_has_pay() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChargeAns::clear_pay() {
  if (pay_ != NULL) pay_->::ts::PayInfo::Clear();
  clear_has_pay();
}
inline const ::ts::PayInfo& ChargeAns::pay() const {
  return pay_ != NULL ? *pay_ : *default_instance_->pay_;
}
inline ::ts::PayInfo* ChargeAns::mutable_pay() {
  set_has_pay();
  if (pay_ == NULL) pay_ = new ::ts::PayInfo;
  return pay_;
}
inline ::ts::PayInfo* ChargeAns::release_pay() {
  clear_has_pay();
  ::ts::PayInfo* temp = pay_;
  pay_ = NULL;
  return temp;
}
inline void ChargeAns::set_allocated_pay(::ts::PayInfo* pay) {
  delete pay_;
  pay_ = pay;
  if (pay) {
    set_has_pay();
  } else {
    clear_has_pay();
  }
}

// -------------------------------------------------------------------

// Pay

// required .ts.ServiceHead head = 1;
inline bool Pay::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pay::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pay::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pay::clear_head() {
  if (head_ != NULL) head_->::ts::ServiceHead::Clear();
  clear_has_head();
}
inline const ::ts::ServiceHead& Pay::head() const {
  return head_ != NULL ? *head_ : *default_instance_->head_;
}
inline ::ts::ServiceHead* Pay::mutable_head() {
  set_has_head();
  if (head_ == NULL) head_ = new ::ts::ServiceHead;
  return head_;
}
inline ::ts::ServiceHead* Pay::release_head() {
  clear_has_head();
  ::ts::ServiceHead* temp = head_;
  head_ = NULL;
  return temp;
}
inline void Pay::set_allocated_head(::ts::ServiceHead* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
}

// required .ts.ClientInfo client = 2;
inline bool Pay::has_client() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pay::set_has_client() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pay::clear_has_client() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pay::clear_client() {
  if (client_ != NULL) client_->::ts::ClientInfo::Clear();
  clear_has_client();
}
inline const ::ts::ClientInfo& Pay::client() const {
  return client_ != NULL ? *client_ : *default_instance_->client_;
}
inline ::ts::ClientInfo* Pay::mutable_client() {
  set_has_client();
  if (client_ == NULL) client_ = new ::ts::ClientInfo;
  return client_;
}
inline ::ts::ClientInfo* Pay::release_client() {
  clear_has_client();
  ::ts::ClientInfo* temp = client_;
  client_ = NULL;
  return temp;
}
inline void Pay::set_allocated_client(::ts::ClientInfo* client) {
  delete client_;
  client_ = client;
  if (client) {
    set_has_client();
  } else {
    clear_has_client();
  }
}

// optional .ts.ProductInfo product = 3;
inline bool Pay::has_product() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Pay::set_has_product() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Pay::clear_has_product() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Pay::clear_product() {
  if (product_ != NULL) product_->::ts::ProductInfo::Clear();
  clear_has_product();
}
inline const ::ts::ProductInfo& Pay::product() const {
  return product_ != NULL ? *product_ : *default_instance_->product_;
}
inline ::ts::ProductInfo* Pay::mutable_product() {
  set_has_product();
  if (product_ == NULL) product_ = new ::ts::ProductInfo;
  return product_;
}
inline ::ts::ProductInfo* Pay::release_product() {
  clear_has_product();
  ::ts::ProductInfo* temp = product_;
  product_ = NULL;
  return temp;
}
inline void Pay::set_allocated_product(::ts::ProductInfo* product) {
  delete product_;
  product_ = product;
  if (product) {
    set_has_product();
  } else {
    clear_has_product();
  }
}

// optional .ts.PayInfo payinfo = 4;
inline bool Pay::has_payinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Pay::set_has_payinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Pay::clear_has_payinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Pay::clear_payinfo() {
  if (payinfo_ != NULL) payinfo_->::ts::PayInfo::Clear();
  clear_has_payinfo();
}
inline const ::ts::PayInfo& Pay::payinfo() const {
  return payinfo_ != NULL ? *payinfo_ : *default_instance_->payinfo_;
}
inline ::ts::PayInfo* Pay::mutable_payinfo() {
  set_has_payinfo();
  if (payinfo_ == NULL) payinfo_ = new ::ts::PayInfo;
  return payinfo_;
}
inline ::ts::PayInfo* Pay::release_payinfo() {
  clear_has_payinfo();
  ::ts::PayInfo* temp = payinfo_;
  payinfo_ = NULL;
  return temp;
}
inline void Pay::set_allocated_payinfo(::ts::PayInfo* payinfo) {
  delete payinfo_;
  payinfo_ = payinfo;
  if (payinfo) {
    set_has_payinfo();
  } else {
    clear_has_payinfo();
  }
}

// optional .ts.ProfitInfo profitinfo = 5;
inline bool Pay::has_profitinfo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Pay::set_has_profitinfo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Pay::clear_has_profitinfo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Pay::clear_profitinfo() {
  if (profitinfo_ != NULL) profitinfo_->::ts::ProfitInfo::Clear();
  clear_has_profitinfo();
}
inline const ::ts::ProfitInfo& Pay::profitinfo() const {
  return profitinfo_ != NULL ? *profitinfo_ : *default_instance_->profitinfo_;
}
inline ::ts::ProfitInfo* Pay::mutable_profitinfo() {
  set_has_profitinfo();
  if (profitinfo_ == NULL) profitinfo_ = new ::ts::ProfitInfo;
  return profitinfo_;
}
inline ::ts::ProfitInfo* Pay::release_profitinfo() {
  clear_has_profitinfo();
  ::ts::ProfitInfo* temp = profitinfo_;
  profitinfo_ = NULL;
  return temp;
}
inline void Pay::set_allocated_profitinfo(::ts::ProfitInfo* profitinfo) {
  delete profitinfo_;
  profitinfo_ = profitinfo;
  if (profitinfo) {
    set_has_profitinfo();
  } else {
    clear_has_profitinfo();
  }
}

// -------------------------------------------------------------------

// PayAns

// required .ts.ServiceHead head = 1;
inline bool PayAns::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PayAns::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PayAns::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PayAns::clear_head() {
  if (head_ != NULL) head_->::ts::ServiceHead::Clear();
  clear_has_head();
}
inline const ::ts::ServiceHead& PayAns::head() const {
  return head_ != NULL ? *head_ : *default_instance_->head_;
}
inline ::ts::ServiceHead* PayAns::mutable_head() {
  set_has_head();
  if (head_ == NULL) head_ = new ::ts::ServiceHead;
  return head_;
}
inline ::ts::ServiceHead* PayAns::release_head() {
  clear_has_head();
  ::ts::ServiceHead* temp = head_;
  head_ = NULL;
  return temp;
}
inline void PayAns::set_allocated_head(::ts::ServiceHead* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
}

// optional .ts.ClientInfo client = 2;
inline bool PayAns::has_client() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PayAns::set_has_client() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PayAns::clear_has_client() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PayAns::clear_client() {
  if (client_ != NULL) client_->::ts::ClientInfo::Clear();
  clear_has_client();
}
inline const ::ts::ClientInfo& PayAns::client() const {
  return client_ != NULL ? *client_ : *default_instance_->client_;
}
inline ::ts::ClientInfo* PayAns::mutable_client() {
  set_has_client();
  if (client_ == NULL) client_ = new ::ts::ClientInfo;
  return client_;
}
inline ::ts::ClientInfo* PayAns::release_client() {
  clear_has_client();
  ::ts::ClientInfo* temp = client_;
  client_ = NULL;
  return temp;
}
inline void PayAns::set_allocated_client(::ts::ClientInfo* client) {
  delete client_;
  client_ = client;
  if (client) {
    set_has_client();
  } else {
    clear_has_client();
  }
}

// optional .ts.ProductInfo product = 3;
inline bool PayAns::has_product() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PayAns::set_has_product() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PayAns::clear_has_product() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PayAns::clear_product() {
  if (product_ != NULL) product_->::ts::ProductInfo::Clear();
  clear_has_product();
}
inline const ::ts::ProductInfo& PayAns::product() const {
  return product_ != NULL ? *product_ : *default_instance_->product_;
}
inline ::ts::ProductInfo* PayAns::mutable_product() {
  set_has_product();
  if (product_ == NULL) product_ = new ::ts::ProductInfo;
  return product_;
}
inline ::ts::ProductInfo* PayAns::release_product() {
  clear_has_product();
  ::ts::ProductInfo* temp = product_;
  product_ = NULL;
  return temp;
}
inline void PayAns::set_allocated_product(::ts::ProductInfo* product) {
  delete product_;
  product_ = product;
  if (product) {
    set_has_product();
  } else {
    clear_has_product();
  }
}

// optional .ts.PayInfo payinfo = 4;
inline bool PayAns::has_payinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PayAns::set_has_payinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PayAns::clear_has_payinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PayAns::clear_payinfo() {
  if (payinfo_ != NULL) payinfo_->::ts::PayInfo::Clear();
  clear_has_payinfo();
}
inline const ::ts::PayInfo& PayAns::payinfo() const {
  return payinfo_ != NULL ? *payinfo_ : *default_instance_->payinfo_;
}
inline ::ts::PayInfo* PayAns::mutable_payinfo() {
  set_has_payinfo();
  if (payinfo_ == NULL) payinfo_ = new ::ts::PayInfo;
  return payinfo_;
}
inline ::ts::PayInfo* PayAns::release_payinfo() {
  clear_has_payinfo();
  ::ts::PayInfo* temp = payinfo_;
  payinfo_ = NULL;
  return temp;
}
inline void PayAns::set_allocated_payinfo(::ts::PayInfo* payinfo) {
  delete payinfo_;
  payinfo_ = payinfo;
  if (payinfo) {
    set_has_payinfo();
  } else {
    clear_has_payinfo();
  }
}

// -------------------------------------------------------------------

// TransAmt

// required .ts.ServiceHead head = 1;
inline bool TransAmt::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransAmt::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransAmt::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransAmt::clear_head() {
  if (head_ != NULL) head_->::ts::ServiceHead::Clear();
  clear_has_head();
}
inline const ::ts::ServiceHead& TransAmt::head() const {
  return head_ != NULL ? *head_ : *default_instance_->head_;
}
inline ::ts::ServiceHead* TransAmt::mutable_head() {
  set_has_head();
  if (head_ == NULL) head_ = new ::ts::ServiceHead;
  return head_;
}
inline ::ts::ServiceHead* TransAmt::release_head() {
  clear_has_head();
  ::ts::ServiceHead* temp = head_;
  head_ = NULL;
  return temp;
}
inline void TransAmt::set_allocated_head(::ts::ServiceHead* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
}

// optional .ts.ClientInfo from_client = 2;
inline bool TransAmt::has_from_client() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransAmt::set_has_from_client() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransAmt::clear_has_from_client() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransAmt::clear_from_client() {
  if (from_client_ != NULL) from_client_->::ts::ClientInfo::Clear();
  clear_has_from_client();
}
inline const ::ts::ClientInfo& TransAmt::from_client() const {
  return from_client_ != NULL ? *from_client_ : *default_instance_->from_client_;
}
inline ::ts::ClientInfo* TransAmt::mutable_from_client() {
  set_has_from_client();
  if (from_client_ == NULL) from_client_ = new ::ts::ClientInfo;
  return from_client_;
}
inline ::ts::ClientInfo* TransAmt::release_from_client() {
  clear_has_from_client();
  ::ts::ClientInfo* temp = from_client_;
  from_client_ = NULL;
  return temp;
}
inline void TransAmt::set_allocated_from_client(::ts::ClientInfo* from_client) {
  delete from_client_;
  from_client_ = from_client;
  if (from_client) {
    set_has_from_client();
  } else {
    clear_has_from_client();
  }
}

// optional .ts.ClientInfo to_client = 3;
inline bool TransAmt::has_to_client() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransAmt::set_has_to_client() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransAmt::clear_has_to_client() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransAmt::clear_to_client() {
  if (to_client_ != NULL) to_client_->::ts::ClientInfo::Clear();
  clear_has_to_client();
}
inline const ::ts::ClientInfo& TransAmt::to_client() const {
  return to_client_ != NULL ? *to_client_ : *default_instance_->to_client_;
}
inline ::ts::ClientInfo* TransAmt::mutable_to_client() {
  set_has_to_client();
  if (to_client_ == NULL) to_client_ = new ::ts::ClientInfo;
  return to_client_;
}
inline ::ts::ClientInfo* TransAmt::release_to_client() {
  clear_has_to_client();
  ::ts::ClientInfo* temp = to_client_;
  to_client_ = NULL;
  return temp;
}
inline void TransAmt::set_allocated_to_client(::ts::ClientInfo* to_client) {
  delete to_client_;
  to_client_ = to_client;
  if (to_client) {
    set_has_to_client();
  } else {
    clear_has_to_client();
  }
}

// optional .ts.PayInfo pay_info = 4;
inline bool TransAmt::has_pay_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransAmt::set_has_pay_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransAmt::clear_has_pay_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransAmt::clear_pay_info() {
  if (pay_info_ != NULL) pay_info_->::ts::PayInfo::Clear();
  clear_has_pay_info();
}
inline const ::ts::PayInfo& TransAmt::pay_info() const {
  return pay_info_ != NULL ? *pay_info_ : *default_instance_->pay_info_;
}
inline ::ts::PayInfo* TransAmt::mutable_pay_info() {
  set_has_pay_info();
  if (pay_info_ == NULL) pay_info_ = new ::ts::PayInfo;
  return pay_info_;
}
inline ::ts::PayInfo* TransAmt::release_pay_info() {
  clear_has_pay_info();
  ::ts::PayInfo* temp = pay_info_;
  pay_info_ = NULL;
  return temp;
}
inline void TransAmt::set_allocated_pay_info(::ts::PayInfo* pay_info) {
  delete pay_info_;
  pay_info_ = pay_info;
  if (pay_info) {
    set_has_pay_info();
  } else {
    clear_has_pay_info();
  }
}

// -------------------------------------------------------------------

// TransAmtAns

// required .ts.ServiceHead head = 1;
inline bool TransAmtAns::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransAmtAns::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransAmtAns::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransAmtAns::clear_head() {
  if (head_ != NULL) head_->::ts::ServiceHead::Clear();
  clear_has_head();
}
inline const ::ts::ServiceHead& TransAmtAns::head() const {
  return head_ != NULL ? *head_ : *default_instance_->head_;
}
inline ::ts::ServiceHead* TransAmtAns::mutable_head() {
  set_has_head();
  if (head_ == NULL) head_ = new ::ts::ServiceHead;
  return head_;
}
inline ::ts::ServiceHead* TransAmtAns::release_head() {
  clear_has_head();
  ::ts::ServiceHead* temp = head_;
  head_ = NULL;
  return temp;
}
inline void TransAmtAns::set_allocated_head(::ts::ServiceHead* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
}

// optional .ts.ClientInfo from_client = 2;
inline bool TransAmtAns::has_from_client() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransAmtAns::set_has_from_client() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransAmtAns::clear_has_from_client() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransAmtAns::clear_from_client() {
  if (from_client_ != NULL) from_client_->::ts::ClientInfo::Clear();
  clear_has_from_client();
}
inline const ::ts::ClientInfo& TransAmtAns::from_client() const {
  return from_client_ != NULL ? *from_client_ : *default_instance_->from_client_;
}
inline ::ts::ClientInfo* TransAmtAns::mutable_from_client() {
  set_has_from_client();
  if (from_client_ == NULL) from_client_ = new ::ts::ClientInfo;
  return from_client_;
}
inline ::ts::ClientInfo* TransAmtAns::release_from_client() {
  clear_has_from_client();
  ::ts::ClientInfo* temp = from_client_;
  from_client_ = NULL;
  return temp;
}
inline void TransAmtAns::set_allocated_from_client(::ts::ClientInfo* from_client) {
  delete from_client_;
  from_client_ = from_client;
  if (from_client) {
    set_has_from_client();
  } else {
    clear_has_from_client();
  }
}

// optional .ts.ClientInfo to_client = 3;
inline bool TransAmtAns::has_to_client() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransAmtAns::set_has_to_client() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransAmtAns::clear_has_to_client() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransAmtAns::clear_to_client() {
  if (to_client_ != NULL) to_client_->::ts::ClientInfo::Clear();
  clear_has_to_client();
}
inline const ::ts::ClientInfo& TransAmtAns::to_client() const {
  return to_client_ != NULL ? *to_client_ : *default_instance_->to_client_;
}
inline ::ts::ClientInfo* TransAmtAns::mutable_to_client() {
  set_has_to_client();
  if (to_client_ == NULL) to_client_ = new ::ts::ClientInfo;
  return to_client_;
}
inline ::ts::ClientInfo* TransAmtAns::release_to_client() {
  clear_has_to_client();
  ::ts::ClientInfo* temp = to_client_;
  to_client_ = NULL;
  return temp;
}
inline void TransAmtAns::set_allocated_to_client(::ts::ClientInfo* to_client) {
  delete to_client_;
  to_client_ = to_client;
  if (to_client) {
    set_has_to_client();
  } else {
    clear_has_to_client();
  }
}

// optional .ts.PayInfo payinfo = 4;
inline bool TransAmtAns::has_payinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransAmtAns::set_has_payinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransAmtAns::clear_has_payinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransAmtAns::clear_payinfo() {
  if (payinfo_ != NULL) payinfo_->::ts::PayInfo::Clear();
  clear_has_payinfo();
}
inline const ::ts::PayInfo& TransAmtAns::payinfo() const {
  return payinfo_ != NULL ? *payinfo_ : *default_instance_->payinfo_;
}
inline ::ts::PayInfo* TransAmtAns::mutable_payinfo() {
  set_has_payinfo();
  if (payinfo_ == NULL) payinfo_ = new ::ts::PayInfo;
  return payinfo_;
}
inline ::ts::PayInfo* TransAmtAns::release_payinfo() {
  clear_has_payinfo();
  ::ts::PayInfo* temp = payinfo_;
  payinfo_ = NULL;
  return temp;
}
inline void TransAmtAns::set_allocated_payinfo(::ts::PayInfo* payinfo) {
  delete payinfo_;
  payinfo_ = payinfo;
  if (payinfo) {
    set_has_payinfo();
  } else {
    clear_has_payinfo();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ts

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_portal_2eproto__INCLUDED
