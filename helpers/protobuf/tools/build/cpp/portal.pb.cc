// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: portal.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "portal.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace ts {

namespace {

const ::google::protobuf::Descriptor* QueryAmt_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  QueryAmt_reflection_ = NULL;
const ::google::protobuf::Descriptor* QueryAmtAns_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  QueryAmtAns_reflection_ = NULL;
const ::google::protobuf::Descriptor* Charge_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Charge_reflection_ = NULL;
const ::google::protobuf::Descriptor* ChargeAns_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ChargeAns_reflection_ = NULL;
const ::google::protobuf::Descriptor* Pay_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Pay_reflection_ = NULL;
const ::google::protobuf::Descriptor* PayAns_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PayAns_reflection_ = NULL;
const ::google::protobuf::Descriptor* TransAmt_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TransAmt_reflection_ = NULL;
const ::google::protobuf::Descriptor* TransAmtAns_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TransAmtAns_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_portal_2eproto() {
  protobuf_AddDesc_portal_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "portal.proto");
  GOOGLE_CHECK(file != NULL);
  QueryAmt_descriptor_ = file->message_type(0);
  static const int QueryAmt_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QueryAmt, head_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QueryAmt, client_),
  };
  QueryAmt_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      QueryAmt_descriptor_,
      QueryAmt::default_instance_,
      QueryAmt_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QueryAmt, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QueryAmt, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(QueryAmt));
  QueryAmtAns_descriptor_ = file->message_type(1);
  static const int QueryAmtAns_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QueryAmtAns, head_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QueryAmtAns, client_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QueryAmtAns, acct_),
  };
  QueryAmtAns_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      QueryAmtAns_descriptor_,
      QueryAmtAns::default_instance_,
      QueryAmtAns_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QueryAmtAns, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QueryAmtAns, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(QueryAmtAns));
  Charge_descriptor_ = file->message_type(2);
  static const int Charge_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Charge, head_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Charge, client_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Charge, pay_),
  };
  Charge_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Charge_descriptor_,
      Charge::default_instance_,
      Charge_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Charge, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Charge, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Charge));
  ChargeAns_descriptor_ = file->message_type(3);
  static const int ChargeAns_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChargeAns, head_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChargeAns, client_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChargeAns, pay_),
  };
  ChargeAns_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ChargeAns_descriptor_,
      ChargeAns::default_instance_,
      ChargeAns_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChargeAns, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChargeAns, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ChargeAns));
  Pay_descriptor_ = file->message_type(4);
  static const int Pay_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pay, head_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pay, client_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pay, product_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pay, payinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pay, profitinfo_),
  };
  Pay_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Pay_descriptor_,
      Pay::default_instance_,
      Pay_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pay, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pay, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Pay));
  PayAns_descriptor_ = file->message_type(5);
  static const int PayAns_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PayAns, head_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PayAns, client_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PayAns, product_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PayAns, payinfo_),
  };
  PayAns_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PayAns_descriptor_,
      PayAns::default_instance_,
      PayAns_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PayAns, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PayAns, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PayAns));
  TransAmt_descriptor_ = file->message_type(6);
  static const int TransAmt_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransAmt, head_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransAmt, from_client_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransAmt, to_client_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransAmt, pay_info_),
  };
  TransAmt_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TransAmt_descriptor_,
      TransAmt::default_instance_,
      TransAmt_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransAmt, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransAmt, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TransAmt));
  TransAmtAns_descriptor_ = file->message_type(7);
  static const int TransAmtAns_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransAmtAns, head_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransAmtAns, from_client_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransAmtAns, to_client_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransAmtAns, payinfo_),
  };
  TransAmtAns_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TransAmtAns_descriptor_,
      TransAmtAns::default_instance_,
      TransAmtAns_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransAmtAns, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransAmtAns, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TransAmtAns));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_portal_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    QueryAmt_descriptor_, &QueryAmt::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    QueryAmtAns_descriptor_, &QueryAmtAns::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Charge_descriptor_, &Charge::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ChargeAns_descriptor_, &ChargeAns::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Pay_descriptor_, &Pay::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PayAns_descriptor_, &PayAns::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TransAmt_descriptor_, &TransAmt::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TransAmtAns_descriptor_, &TransAmtAns::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_portal_2eproto() {
  delete QueryAmt::default_instance_;
  delete QueryAmt_reflection_;
  delete QueryAmtAns::default_instance_;
  delete QueryAmtAns_reflection_;
  delete Charge::default_instance_;
  delete Charge_reflection_;
  delete ChargeAns::default_instance_;
  delete ChargeAns_reflection_;
  delete Pay::default_instance_;
  delete Pay_reflection_;
  delete PayAns::default_instance_;
  delete PayAns_reflection_;
  delete TransAmt::default_instance_;
  delete TransAmt_reflection_;
  delete TransAmtAns::default_instance_;
  delete TransAmtAns_reflection_;
}

void protobuf_AddDesc_portal_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::ts::protobuf_AddDesc_head_2eproto();
  ::ts::protobuf_AddDesc_client_2eproto();
  ::ts::protobuf_AddDesc_pay_2eproto();
  ::ts::protobuf_AddDesc_product_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\014portal.proto\022\002ts\032\nhead.proto\032\014client.p"
    "roto\032\tpay.proto\032\rproduct.proto\"I\n\010QueryA"
    "mt\022\035\n\004head\030\001 \002(\0132\017.ts.ServiceHead\022\036\n\006cli"
    "ent\030\002 \003(\0132\016.ts.ClientInfo\"h\n\013QueryAmtAns"
    "\022\035\n\004head\030\001 \002(\0132\017.ts.ServiceHead\022\036\n\006clien"
    "t\030\002 \003(\0132\016.ts.ClientInfo\022\032\n\004acct\030\003 \003(\0132\014."
    "ts.AcctInfo\"a\n\006Charge\022\035\n\004head\030\001 \002(\0132\017.ts"
    ".ServiceHead\022\036\n\006client\030\002 \001(\0132\016.ts.Client"
    "Info\022\030\n\003pay\030\003 \001(\0132\013.ts.PayInfo\"d\n\tCharge"
    "Ans\022\035\n\004head\030\001 \002(\0132\017.ts.ServiceHead\022\036\n\006cl"
    "ient\030\002 \001(\0132\016.ts.ClientInfo\022\030\n\003pay\030\003 \001(\0132"
    "\013.ts.PayInfo\"\250\001\n\003Pay\022\035\n\004head\030\001 \002(\0132\017.ts."
    "ServiceHead\022\036\n\006client\030\002 \002(\0132\016.ts.ClientI"
    "nfo\022 \n\007product\030\003 \001(\0132\017.ts.ProductInfo\022\034\n"
    "\007payinfo\030\004 \001(\0132\013.ts.PayInfo\022\"\n\nprofitinf"
    "o\030\005 \001(\0132\016.ts.ProfitInfo\"\207\001\n\006PayAns\022\035\n\004he"
    "ad\030\001 \002(\0132\017.ts.ServiceHead\022\036\n\006client\030\002 \001("
    "\0132\016.ts.ClientInfo\022 \n\007product\030\003 \001(\0132\017.ts."
    "ProductInfo\022\034\n\007payinfo\030\004 \001(\0132\013.ts.PayInf"
    "o\"\220\001\n\010TransAmt\022\035\n\004head\030\001 \002(\0132\017.ts.Servic"
    "eHead\022#\n\013from_client\030\002 \001(\0132\016.ts.ClientIn"
    "fo\022!\n\tto_client\030\003 \001(\0132\016.ts.ClientInfo\022\035\n"
    "\010pay_info\030\004 \001(\0132\013.ts.PayInfo\"\222\001\n\013TransAm"
    "tAns\022\035\n\004head\030\001 \002(\0132\017.ts.ServiceHead\022#\n\013f"
    "rom_client\030\002 \001(\0132\016.ts.ClientInfo\022!\n\tto_c"
    "lient\030\003 \001(\0132\016.ts.ClientInfo\022\034\n\007payinfo\030\004"
    " \001(\0132\013.ts.PayInfo", 1057);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "portal.proto", &protobuf_RegisterTypes);
  QueryAmt::default_instance_ = new QueryAmt();
  QueryAmtAns::default_instance_ = new QueryAmtAns();
  Charge::default_instance_ = new Charge();
  ChargeAns::default_instance_ = new ChargeAns();
  Pay::default_instance_ = new Pay();
  PayAns::default_instance_ = new PayAns();
  TransAmt::default_instance_ = new TransAmt();
  TransAmtAns::default_instance_ = new TransAmtAns();
  QueryAmt::default_instance_->InitAsDefaultInstance();
  QueryAmtAns::default_instance_->InitAsDefaultInstance();
  Charge::default_instance_->InitAsDefaultInstance();
  ChargeAns::default_instance_->InitAsDefaultInstance();
  Pay::default_instance_->InitAsDefaultInstance();
  PayAns::default_instance_->InitAsDefaultInstance();
  TransAmt::default_instance_->InitAsDefaultInstance();
  TransAmtAns::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_portal_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_portal_2eproto {
  StaticDescriptorInitializer_portal_2eproto() {
    protobuf_AddDesc_portal_2eproto();
  }
} static_descriptor_initializer_portal_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int QueryAmt::kHeadFieldNumber;
const int QueryAmt::kClientFieldNumber;
#endif  // !_MSC_VER

QueryAmt::QueryAmt()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void QueryAmt::InitAsDefaultInstance() {
  head_ = const_cast< ::ts::ServiceHead*>(&::ts::ServiceHead::default_instance());
}

QueryAmt::QueryAmt(const QueryAmt& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void QueryAmt::SharedCtor() {
  _cached_size_ = 0;
  head_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

QueryAmt::~QueryAmt() {
  SharedDtor();
}

void QueryAmt::SharedDtor() {
  if (this != default_instance_) {
    delete head_;
  }
}

void QueryAmt::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* QueryAmt::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return QueryAmt_descriptor_;
}

const QueryAmt& QueryAmt::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_portal_2eproto();
  return *default_instance_;
}

QueryAmt* QueryAmt::default_instance_ = NULL;

QueryAmt* QueryAmt::New() const {
  return new QueryAmt;
}

void QueryAmt::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_head()) {
      if (head_ != NULL) head_->::ts::ServiceHead::Clear();
    }
  }
  client_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool QueryAmt::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ts.ServiceHead head = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_head()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_client;
        break;
      }

      // repeated .ts.ClientInfo client = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_client:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_client()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_client;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void QueryAmt::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .ts.ServiceHead head = 1;
  if (has_head()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->head(), output);
  }

  // repeated .ts.ClientInfo client = 2;
  for (int i = 0; i < this->client_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->client(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* QueryAmt::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .ts.ServiceHead head = 1;
  if (has_head()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->head(), target);
  }

  // repeated .ts.ClientInfo client = 2;
  for (int i = 0; i < this->client_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->client(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int QueryAmt::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ts.ServiceHead head = 1;
    if (has_head()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->head());
    }

  }
  // repeated .ts.ClientInfo client = 2;
  total_size += 1 * this->client_size();
  for (int i = 0; i < this->client_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->client(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void QueryAmt::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const QueryAmt* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const QueryAmt*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void QueryAmt::MergeFrom(const QueryAmt& from) {
  GOOGLE_CHECK_NE(&from, this);
  client_.MergeFrom(from.client_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_head()) {
      mutable_head()->::ts::ServiceHead::MergeFrom(from.head());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void QueryAmt::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void QueryAmt::CopyFrom(const QueryAmt& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QueryAmt::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_head()) {
    if (!this->head().IsInitialized()) return false;
  }
  for (int i = 0; i < client_size(); i++) {
    if (!this->client(i).IsInitialized()) return false;
  }
  return true;
}

void QueryAmt::Swap(QueryAmt* other) {
  if (other != this) {
    std::swap(head_, other->head_);
    client_.Swap(&other->client_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata QueryAmt::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = QueryAmt_descriptor_;
  metadata.reflection = QueryAmt_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int QueryAmtAns::kHeadFieldNumber;
const int QueryAmtAns::kClientFieldNumber;
const int QueryAmtAns::kAcctFieldNumber;
#endif  // !_MSC_VER

QueryAmtAns::QueryAmtAns()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void QueryAmtAns::InitAsDefaultInstance() {
  head_ = const_cast< ::ts::ServiceHead*>(&::ts::ServiceHead::default_instance());
}

QueryAmtAns::QueryAmtAns(const QueryAmtAns& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void QueryAmtAns::SharedCtor() {
  _cached_size_ = 0;
  head_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

QueryAmtAns::~QueryAmtAns() {
  SharedDtor();
}

void QueryAmtAns::SharedDtor() {
  if (this != default_instance_) {
    delete head_;
  }
}

void QueryAmtAns::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* QueryAmtAns::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return QueryAmtAns_descriptor_;
}

const QueryAmtAns& QueryAmtAns::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_portal_2eproto();
  return *default_instance_;
}

QueryAmtAns* QueryAmtAns::default_instance_ = NULL;

QueryAmtAns* QueryAmtAns::New() const {
  return new QueryAmtAns;
}

void QueryAmtAns::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_head()) {
      if (head_ != NULL) head_->::ts::ServiceHead::Clear();
    }
  }
  client_.Clear();
  acct_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool QueryAmtAns::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ts.ServiceHead head = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_head()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_client;
        break;
      }

      // repeated .ts.ClientInfo client = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_client:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_client()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_client;
        if (input->ExpectTag(26)) goto parse_acct;
        break;
      }

      // repeated .ts.AcctInfo acct = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_acct:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_acct()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_acct;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void QueryAmtAns::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .ts.ServiceHead head = 1;
  if (has_head()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->head(), output);
  }

  // repeated .ts.ClientInfo client = 2;
  for (int i = 0; i < this->client_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->client(i), output);
  }

  // repeated .ts.AcctInfo acct = 3;
  for (int i = 0; i < this->acct_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->acct(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* QueryAmtAns::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .ts.ServiceHead head = 1;
  if (has_head()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->head(), target);
  }

  // repeated .ts.ClientInfo client = 2;
  for (int i = 0; i < this->client_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->client(i), target);
  }

  // repeated .ts.AcctInfo acct = 3;
  for (int i = 0; i < this->acct_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->acct(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int QueryAmtAns::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ts.ServiceHead head = 1;
    if (has_head()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->head());
    }

  }
  // repeated .ts.ClientInfo client = 2;
  total_size += 1 * this->client_size();
  for (int i = 0; i < this->client_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->client(i));
  }

  // repeated .ts.AcctInfo acct = 3;
  total_size += 1 * this->acct_size();
  for (int i = 0; i < this->acct_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->acct(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void QueryAmtAns::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const QueryAmtAns* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const QueryAmtAns*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void QueryAmtAns::MergeFrom(const QueryAmtAns& from) {
  GOOGLE_CHECK_NE(&from, this);
  client_.MergeFrom(from.client_);
  acct_.MergeFrom(from.acct_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_head()) {
      mutable_head()->::ts::ServiceHead::MergeFrom(from.head());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void QueryAmtAns::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void QueryAmtAns::CopyFrom(const QueryAmtAns& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QueryAmtAns::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_head()) {
    if (!this->head().IsInitialized()) return false;
  }
  for (int i = 0; i < client_size(); i++) {
    if (!this->client(i).IsInitialized()) return false;
  }
  for (int i = 0; i < acct_size(); i++) {
    if (!this->acct(i).IsInitialized()) return false;
  }
  return true;
}

void QueryAmtAns::Swap(QueryAmtAns* other) {
  if (other != this) {
    std::swap(head_, other->head_);
    client_.Swap(&other->client_);
    acct_.Swap(&other->acct_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata QueryAmtAns::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = QueryAmtAns_descriptor_;
  metadata.reflection = QueryAmtAns_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Charge::kHeadFieldNumber;
const int Charge::kClientFieldNumber;
const int Charge::kPayFieldNumber;
#endif  // !_MSC_VER

Charge::Charge()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Charge::InitAsDefaultInstance() {
  head_ = const_cast< ::ts::ServiceHead*>(&::ts::ServiceHead::default_instance());
  client_ = const_cast< ::ts::ClientInfo*>(&::ts::ClientInfo::default_instance());
  pay_ = const_cast< ::ts::PayInfo*>(&::ts::PayInfo::default_instance());
}

Charge::Charge(const Charge& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Charge::SharedCtor() {
  _cached_size_ = 0;
  head_ = NULL;
  client_ = NULL;
  pay_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Charge::~Charge() {
  SharedDtor();
}

void Charge::SharedDtor() {
  if (this != default_instance_) {
    delete head_;
    delete client_;
    delete pay_;
  }
}

void Charge::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Charge::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Charge_descriptor_;
}

const Charge& Charge::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_portal_2eproto();
  return *default_instance_;
}

Charge* Charge::default_instance_ = NULL;

Charge* Charge::New() const {
  return new Charge;
}

void Charge::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_head()) {
      if (head_ != NULL) head_->::ts::ServiceHead::Clear();
    }
    if (has_client()) {
      if (client_ != NULL) client_->::ts::ClientInfo::Clear();
    }
    if (has_pay()) {
      if (pay_ != NULL) pay_->::ts::PayInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Charge::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ts.ServiceHead head = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_head()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_client;
        break;
      }

      // optional .ts.ClientInfo client = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_client:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_client()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_pay;
        break;
      }

      // optional .ts.PayInfo pay = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pay:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pay()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Charge::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .ts.ServiceHead head = 1;
  if (has_head()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->head(), output);
  }

  // optional .ts.ClientInfo client = 2;
  if (has_client()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->client(), output);
  }

  // optional .ts.PayInfo pay = 3;
  if (has_pay()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->pay(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Charge::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .ts.ServiceHead head = 1;
  if (has_head()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->head(), target);
  }

  // optional .ts.ClientInfo client = 2;
  if (has_client()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->client(), target);
  }

  // optional .ts.PayInfo pay = 3;
  if (has_pay()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->pay(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Charge::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ts.ServiceHead head = 1;
    if (has_head()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->head());
    }

    // optional .ts.ClientInfo client = 2;
    if (has_client()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->client());
    }

    // optional .ts.PayInfo pay = 3;
    if (has_pay()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->pay());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Charge::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Charge* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Charge*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Charge::MergeFrom(const Charge& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_head()) {
      mutable_head()->::ts::ServiceHead::MergeFrom(from.head());
    }
    if (from.has_client()) {
      mutable_client()->::ts::ClientInfo::MergeFrom(from.client());
    }
    if (from.has_pay()) {
      mutable_pay()->::ts::PayInfo::MergeFrom(from.pay());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Charge::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Charge::CopyFrom(const Charge& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Charge::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_head()) {
    if (!this->head().IsInitialized()) return false;
  }
  if (has_client()) {
    if (!this->client().IsInitialized()) return false;
  }
  if (has_pay()) {
    if (!this->pay().IsInitialized()) return false;
  }
  return true;
}

void Charge::Swap(Charge* other) {
  if (other != this) {
    std::swap(head_, other->head_);
    std::swap(client_, other->client_);
    std::swap(pay_, other->pay_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Charge::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Charge_descriptor_;
  metadata.reflection = Charge_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ChargeAns::kHeadFieldNumber;
const int ChargeAns::kClientFieldNumber;
const int ChargeAns::kPayFieldNumber;
#endif  // !_MSC_VER

ChargeAns::ChargeAns()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ChargeAns::InitAsDefaultInstance() {
  head_ = const_cast< ::ts::ServiceHead*>(&::ts::ServiceHead::default_instance());
  client_ = const_cast< ::ts::ClientInfo*>(&::ts::ClientInfo::default_instance());
  pay_ = const_cast< ::ts::PayInfo*>(&::ts::PayInfo::default_instance());
}

ChargeAns::ChargeAns(const ChargeAns& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ChargeAns::SharedCtor() {
  _cached_size_ = 0;
  head_ = NULL;
  client_ = NULL;
  pay_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChargeAns::~ChargeAns() {
  SharedDtor();
}

void ChargeAns::SharedDtor() {
  if (this != default_instance_) {
    delete head_;
    delete client_;
    delete pay_;
  }
}

void ChargeAns::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ChargeAns::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ChargeAns_descriptor_;
}

const ChargeAns& ChargeAns::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_portal_2eproto();
  return *default_instance_;
}

ChargeAns* ChargeAns::default_instance_ = NULL;

ChargeAns* ChargeAns::New() const {
  return new ChargeAns;
}

void ChargeAns::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_head()) {
      if (head_ != NULL) head_->::ts::ServiceHead::Clear();
    }
    if (has_client()) {
      if (client_ != NULL) client_->::ts::ClientInfo::Clear();
    }
    if (has_pay()) {
      if (pay_ != NULL) pay_->::ts::PayInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ChargeAns::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ts.ServiceHead head = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_head()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_client;
        break;
      }

      // optional .ts.ClientInfo client = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_client:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_client()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_pay;
        break;
      }

      // optional .ts.PayInfo pay = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pay:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pay()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChargeAns::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .ts.ServiceHead head = 1;
  if (has_head()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->head(), output);
  }

  // optional .ts.ClientInfo client = 2;
  if (has_client()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->client(), output);
  }

  // optional .ts.PayInfo pay = 3;
  if (has_pay()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->pay(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ChargeAns::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .ts.ServiceHead head = 1;
  if (has_head()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->head(), target);
  }

  // optional .ts.ClientInfo client = 2;
  if (has_client()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->client(), target);
  }

  // optional .ts.PayInfo pay = 3;
  if (has_pay()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->pay(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ChargeAns::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ts.ServiceHead head = 1;
    if (has_head()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->head());
    }

    // optional .ts.ClientInfo client = 2;
    if (has_client()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->client());
    }

    // optional .ts.PayInfo pay = 3;
    if (has_pay()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->pay());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChargeAns::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ChargeAns* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ChargeAns*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ChargeAns::MergeFrom(const ChargeAns& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_head()) {
      mutable_head()->::ts::ServiceHead::MergeFrom(from.head());
    }
    if (from.has_client()) {
      mutable_client()->::ts::ClientInfo::MergeFrom(from.client());
    }
    if (from.has_pay()) {
      mutable_pay()->::ts::PayInfo::MergeFrom(from.pay());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ChargeAns::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ChargeAns::CopyFrom(const ChargeAns& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChargeAns::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_head()) {
    if (!this->head().IsInitialized()) return false;
  }
  if (has_client()) {
    if (!this->client().IsInitialized()) return false;
  }
  if (has_pay()) {
    if (!this->pay().IsInitialized()) return false;
  }
  return true;
}

void ChargeAns::Swap(ChargeAns* other) {
  if (other != this) {
    std::swap(head_, other->head_);
    std::swap(client_, other->client_);
    std::swap(pay_, other->pay_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ChargeAns::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ChargeAns_descriptor_;
  metadata.reflection = ChargeAns_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Pay::kHeadFieldNumber;
const int Pay::kClientFieldNumber;
const int Pay::kProductFieldNumber;
const int Pay::kPayinfoFieldNumber;
const int Pay::kProfitinfoFieldNumber;
#endif  // !_MSC_VER

Pay::Pay()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Pay::InitAsDefaultInstance() {
  head_ = const_cast< ::ts::ServiceHead*>(&::ts::ServiceHead::default_instance());
  client_ = const_cast< ::ts::ClientInfo*>(&::ts::ClientInfo::default_instance());
  product_ = const_cast< ::ts::ProductInfo*>(&::ts::ProductInfo::default_instance());
  payinfo_ = const_cast< ::ts::PayInfo*>(&::ts::PayInfo::default_instance());
  profitinfo_ = const_cast< ::ts::ProfitInfo*>(&::ts::ProfitInfo::default_instance());
}

Pay::Pay(const Pay& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Pay::SharedCtor() {
  _cached_size_ = 0;
  head_ = NULL;
  client_ = NULL;
  product_ = NULL;
  payinfo_ = NULL;
  profitinfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Pay::~Pay() {
  SharedDtor();
}

void Pay::SharedDtor() {
  if (this != default_instance_) {
    delete head_;
    delete client_;
    delete product_;
    delete payinfo_;
    delete profitinfo_;
  }
}

void Pay::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Pay::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Pay_descriptor_;
}

const Pay& Pay::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_portal_2eproto();
  return *default_instance_;
}

Pay* Pay::default_instance_ = NULL;

Pay* Pay::New() const {
  return new Pay;
}

void Pay::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_head()) {
      if (head_ != NULL) head_->::ts::ServiceHead::Clear();
    }
    if (has_client()) {
      if (client_ != NULL) client_->::ts::ClientInfo::Clear();
    }
    if (has_product()) {
      if (product_ != NULL) product_->::ts::ProductInfo::Clear();
    }
    if (has_payinfo()) {
      if (payinfo_ != NULL) payinfo_->::ts::PayInfo::Clear();
    }
    if (has_profitinfo()) {
      if (profitinfo_ != NULL) profitinfo_->::ts::ProfitInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Pay::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ts.ServiceHead head = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_head()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_client;
        break;
      }

      // required .ts.ClientInfo client = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_client:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_client()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_product;
        break;
      }

      // optional .ts.ProductInfo product = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_product:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_product()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_payinfo;
        break;
      }

      // optional .ts.PayInfo payinfo = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_payinfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_payinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_profitinfo;
        break;
      }

      // optional .ts.ProfitInfo profitinfo = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_profitinfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_profitinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Pay::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .ts.ServiceHead head = 1;
  if (has_head()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->head(), output);
  }

  // required .ts.ClientInfo client = 2;
  if (has_client()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->client(), output);
  }

  // optional .ts.ProductInfo product = 3;
  if (has_product()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->product(), output);
  }

  // optional .ts.PayInfo payinfo = 4;
  if (has_payinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->payinfo(), output);
  }

  // optional .ts.ProfitInfo profitinfo = 5;
  if (has_profitinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->profitinfo(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Pay::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .ts.ServiceHead head = 1;
  if (has_head()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->head(), target);
  }

  // required .ts.ClientInfo client = 2;
  if (has_client()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->client(), target);
  }

  // optional .ts.ProductInfo product = 3;
  if (has_product()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->product(), target);
  }

  // optional .ts.PayInfo payinfo = 4;
  if (has_payinfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->payinfo(), target);
  }

  // optional .ts.ProfitInfo profitinfo = 5;
  if (has_profitinfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->profitinfo(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Pay::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ts.ServiceHead head = 1;
    if (has_head()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->head());
    }

    // required .ts.ClientInfo client = 2;
    if (has_client()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->client());
    }

    // optional .ts.ProductInfo product = 3;
    if (has_product()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->product());
    }

    // optional .ts.PayInfo payinfo = 4;
    if (has_payinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->payinfo());
    }

    // optional .ts.ProfitInfo profitinfo = 5;
    if (has_profitinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->profitinfo());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Pay::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Pay* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Pay*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Pay::MergeFrom(const Pay& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_head()) {
      mutable_head()->::ts::ServiceHead::MergeFrom(from.head());
    }
    if (from.has_client()) {
      mutable_client()->::ts::ClientInfo::MergeFrom(from.client());
    }
    if (from.has_product()) {
      mutable_product()->::ts::ProductInfo::MergeFrom(from.product());
    }
    if (from.has_payinfo()) {
      mutable_payinfo()->::ts::PayInfo::MergeFrom(from.payinfo());
    }
    if (from.has_profitinfo()) {
      mutable_profitinfo()->::ts::ProfitInfo::MergeFrom(from.profitinfo());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Pay::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Pay::CopyFrom(const Pay& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pay::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_head()) {
    if (!this->head().IsInitialized()) return false;
  }
  if (has_client()) {
    if (!this->client().IsInitialized()) return false;
  }
  if (has_product()) {
    if (!this->product().IsInitialized()) return false;
  }
  if (has_payinfo()) {
    if (!this->payinfo().IsInitialized()) return false;
  }
  if (has_profitinfo()) {
    if (!this->profitinfo().IsInitialized()) return false;
  }
  return true;
}

void Pay::Swap(Pay* other) {
  if (other != this) {
    std::swap(head_, other->head_);
    std::swap(client_, other->client_);
    std::swap(product_, other->product_);
    std::swap(payinfo_, other->payinfo_);
    std::swap(profitinfo_, other->profitinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Pay::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Pay_descriptor_;
  metadata.reflection = Pay_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PayAns::kHeadFieldNumber;
const int PayAns::kClientFieldNumber;
const int PayAns::kProductFieldNumber;
const int PayAns::kPayinfoFieldNumber;
#endif  // !_MSC_VER

PayAns::PayAns()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PayAns::InitAsDefaultInstance() {
  head_ = const_cast< ::ts::ServiceHead*>(&::ts::ServiceHead::default_instance());
  client_ = const_cast< ::ts::ClientInfo*>(&::ts::ClientInfo::default_instance());
  product_ = const_cast< ::ts::ProductInfo*>(&::ts::ProductInfo::default_instance());
  payinfo_ = const_cast< ::ts::PayInfo*>(&::ts::PayInfo::default_instance());
}

PayAns::PayAns(const PayAns& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PayAns::SharedCtor() {
  _cached_size_ = 0;
  head_ = NULL;
  client_ = NULL;
  product_ = NULL;
  payinfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PayAns::~PayAns() {
  SharedDtor();
}

void PayAns::SharedDtor() {
  if (this != default_instance_) {
    delete head_;
    delete client_;
    delete product_;
    delete payinfo_;
  }
}

void PayAns::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PayAns::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PayAns_descriptor_;
}

const PayAns& PayAns::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_portal_2eproto();
  return *default_instance_;
}

PayAns* PayAns::default_instance_ = NULL;

PayAns* PayAns::New() const {
  return new PayAns;
}

void PayAns::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_head()) {
      if (head_ != NULL) head_->::ts::ServiceHead::Clear();
    }
    if (has_client()) {
      if (client_ != NULL) client_->::ts::ClientInfo::Clear();
    }
    if (has_product()) {
      if (product_ != NULL) product_->::ts::ProductInfo::Clear();
    }
    if (has_payinfo()) {
      if (payinfo_ != NULL) payinfo_->::ts::PayInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PayAns::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ts.ServiceHead head = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_head()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_client;
        break;
      }

      // optional .ts.ClientInfo client = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_client:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_client()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_product;
        break;
      }

      // optional .ts.ProductInfo product = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_product:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_product()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_payinfo;
        break;
      }

      // optional .ts.PayInfo payinfo = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_payinfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_payinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PayAns::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .ts.ServiceHead head = 1;
  if (has_head()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->head(), output);
  }

  // optional .ts.ClientInfo client = 2;
  if (has_client()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->client(), output);
  }

  // optional .ts.ProductInfo product = 3;
  if (has_product()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->product(), output);
  }

  // optional .ts.PayInfo payinfo = 4;
  if (has_payinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->payinfo(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PayAns::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .ts.ServiceHead head = 1;
  if (has_head()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->head(), target);
  }

  // optional .ts.ClientInfo client = 2;
  if (has_client()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->client(), target);
  }

  // optional .ts.ProductInfo product = 3;
  if (has_product()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->product(), target);
  }

  // optional .ts.PayInfo payinfo = 4;
  if (has_payinfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->payinfo(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PayAns::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ts.ServiceHead head = 1;
    if (has_head()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->head());
    }

    // optional .ts.ClientInfo client = 2;
    if (has_client()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->client());
    }

    // optional .ts.ProductInfo product = 3;
    if (has_product()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->product());
    }

    // optional .ts.PayInfo payinfo = 4;
    if (has_payinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->payinfo());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PayAns::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PayAns* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PayAns*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PayAns::MergeFrom(const PayAns& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_head()) {
      mutable_head()->::ts::ServiceHead::MergeFrom(from.head());
    }
    if (from.has_client()) {
      mutable_client()->::ts::ClientInfo::MergeFrom(from.client());
    }
    if (from.has_product()) {
      mutable_product()->::ts::ProductInfo::MergeFrom(from.product());
    }
    if (from.has_payinfo()) {
      mutable_payinfo()->::ts::PayInfo::MergeFrom(from.payinfo());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PayAns::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PayAns::CopyFrom(const PayAns& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PayAns::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_head()) {
    if (!this->head().IsInitialized()) return false;
  }
  if (has_client()) {
    if (!this->client().IsInitialized()) return false;
  }
  if (has_product()) {
    if (!this->product().IsInitialized()) return false;
  }
  if (has_payinfo()) {
    if (!this->payinfo().IsInitialized()) return false;
  }
  return true;
}

void PayAns::Swap(PayAns* other) {
  if (other != this) {
    std::swap(head_, other->head_);
    std::swap(client_, other->client_);
    std::swap(product_, other->product_);
    std::swap(payinfo_, other->payinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PayAns::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PayAns_descriptor_;
  metadata.reflection = PayAns_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TransAmt::kHeadFieldNumber;
const int TransAmt::kFromClientFieldNumber;
const int TransAmt::kToClientFieldNumber;
const int TransAmt::kPayInfoFieldNumber;
#endif  // !_MSC_VER

TransAmt::TransAmt()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TransAmt::InitAsDefaultInstance() {
  head_ = const_cast< ::ts::ServiceHead*>(&::ts::ServiceHead::default_instance());
  from_client_ = const_cast< ::ts::ClientInfo*>(&::ts::ClientInfo::default_instance());
  to_client_ = const_cast< ::ts::ClientInfo*>(&::ts::ClientInfo::default_instance());
  pay_info_ = const_cast< ::ts::PayInfo*>(&::ts::PayInfo::default_instance());
}

TransAmt::TransAmt(const TransAmt& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TransAmt::SharedCtor() {
  _cached_size_ = 0;
  head_ = NULL;
  from_client_ = NULL;
  to_client_ = NULL;
  pay_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TransAmt::~TransAmt() {
  SharedDtor();
}

void TransAmt::SharedDtor() {
  if (this != default_instance_) {
    delete head_;
    delete from_client_;
    delete to_client_;
    delete pay_info_;
  }
}

void TransAmt::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TransAmt::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TransAmt_descriptor_;
}

const TransAmt& TransAmt::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_portal_2eproto();
  return *default_instance_;
}

TransAmt* TransAmt::default_instance_ = NULL;

TransAmt* TransAmt::New() const {
  return new TransAmt;
}

void TransAmt::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_head()) {
      if (head_ != NULL) head_->::ts::ServiceHead::Clear();
    }
    if (has_from_client()) {
      if (from_client_ != NULL) from_client_->::ts::ClientInfo::Clear();
    }
    if (has_to_client()) {
      if (to_client_ != NULL) to_client_->::ts::ClientInfo::Clear();
    }
    if (has_pay_info()) {
      if (pay_info_ != NULL) pay_info_->::ts::PayInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TransAmt::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ts.ServiceHead head = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_head()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_from_client;
        break;
      }

      // optional .ts.ClientInfo from_client = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_from_client:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_from_client()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_to_client;
        break;
      }

      // optional .ts.ClientInfo to_client = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_to_client:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_to_client()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_pay_info;
        break;
      }

      // optional .ts.PayInfo pay_info = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pay_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pay_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TransAmt::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .ts.ServiceHead head = 1;
  if (has_head()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->head(), output);
  }

  // optional .ts.ClientInfo from_client = 2;
  if (has_from_client()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->from_client(), output);
  }

  // optional .ts.ClientInfo to_client = 3;
  if (has_to_client()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->to_client(), output);
  }

  // optional .ts.PayInfo pay_info = 4;
  if (has_pay_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->pay_info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TransAmt::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .ts.ServiceHead head = 1;
  if (has_head()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->head(), target);
  }

  // optional .ts.ClientInfo from_client = 2;
  if (has_from_client()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->from_client(), target);
  }

  // optional .ts.ClientInfo to_client = 3;
  if (has_to_client()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->to_client(), target);
  }

  // optional .ts.PayInfo pay_info = 4;
  if (has_pay_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->pay_info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TransAmt::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ts.ServiceHead head = 1;
    if (has_head()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->head());
    }

    // optional .ts.ClientInfo from_client = 2;
    if (has_from_client()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->from_client());
    }

    // optional .ts.ClientInfo to_client = 3;
    if (has_to_client()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->to_client());
    }

    // optional .ts.PayInfo pay_info = 4;
    if (has_pay_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->pay_info());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransAmt::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TransAmt* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TransAmt*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TransAmt::MergeFrom(const TransAmt& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_head()) {
      mutable_head()->::ts::ServiceHead::MergeFrom(from.head());
    }
    if (from.has_from_client()) {
      mutable_from_client()->::ts::ClientInfo::MergeFrom(from.from_client());
    }
    if (from.has_to_client()) {
      mutable_to_client()->::ts::ClientInfo::MergeFrom(from.to_client());
    }
    if (from.has_pay_info()) {
      mutable_pay_info()->::ts::PayInfo::MergeFrom(from.pay_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TransAmt::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TransAmt::CopyFrom(const TransAmt& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransAmt::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_head()) {
    if (!this->head().IsInitialized()) return false;
  }
  if (has_from_client()) {
    if (!this->from_client().IsInitialized()) return false;
  }
  if (has_to_client()) {
    if (!this->to_client().IsInitialized()) return false;
  }
  if (has_pay_info()) {
    if (!this->pay_info().IsInitialized()) return false;
  }
  return true;
}

void TransAmt::Swap(TransAmt* other) {
  if (other != this) {
    std::swap(head_, other->head_);
    std::swap(from_client_, other->from_client_);
    std::swap(to_client_, other->to_client_);
    std::swap(pay_info_, other->pay_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TransAmt::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TransAmt_descriptor_;
  metadata.reflection = TransAmt_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TransAmtAns::kHeadFieldNumber;
const int TransAmtAns::kFromClientFieldNumber;
const int TransAmtAns::kToClientFieldNumber;
const int TransAmtAns::kPayinfoFieldNumber;
#endif  // !_MSC_VER

TransAmtAns::TransAmtAns()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TransAmtAns::InitAsDefaultInstance() {
  head_ = const_cast< ::ts::ServiceHead*>(&::ts::ServiceHead::default_instance());
  from_client_ = const_cast< ::ts::ClientInfo*>(&::ts::ClientInfo::default_instance());
  to_client_ = const_cast< ::ts::ClientInfo*>(&::ts::ClientInfo::default_instance());
  payinfo_ = const_cast< ::ts::PayInfo*>(&::ts::PayInfo::default_instance());
}

TransAmtAns::TransAmtAns(const TransAmtAns& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TransAmtAns::SharedCtor() {
  _cached_size_ = 0;
  head_ = NULL;
  from_client_ = NULL;
  to_client_ = NULL;
  payinfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TransAmtAns::~TransAmtAns() {
  SharedDtor();
}

void TransAmtAns::SharedDtor() {
  if (this != default_instance_) {
    delete head_;
    delete from_client_;
    delete to_client_;
    delete payinfo_;
  }
}

void TransAmtAns::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TransAmtAns::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TransAmtAns_descriptor_;
}

const TransAmtAns& TransAmtAns::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_portal_2eproto();
  return *default_instance_;
}

TransAmtAns* TransAmtAns::default_instance_ = NULL;

TransAmtAns* TransAmtAns::New() const {
  return new TransAmtAns;
}

void TransAmtAns::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_head()) {
      if (head_ != NULL) head_->::ts::ServiceHead::Clear();
    }
    if (has_from_client()) {
      if (from_client_ != NULL) from_client_->::ts::ClientInfo::Clear();
    }
    if (has_to_client()) {
      if (to_client_ != NULL) to_client_->::ts::ClientInfo::Clear();
    }
    if (has_payinfo()) {
      if (payinfo_ != NULL) payinfo_->::ts::PayInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TransAmtAns::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ts.ServiceHead head = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_head()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_from_client;
        break;
      }

      // optional .ts.ClientInfo from_client = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_from_client:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_from_client()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_to_client;
        break;
      }

      // optional .ts.ClientInfo to_client = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_to_client:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_to_client()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_payinfo;
        break;
      }

      // optional .ts.PayInfo payinfo = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_payinfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_payinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TransAmtAns::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .ts.ServiceHead head = 1;
  if (has_head()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->head(), output);
  }

  // optional .ts.ClientInfo from_client = 2;
  if (has_from_client()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->from_client(), output);
  }

  // optional .ts.ClientInfo to_client = 3;
  if (has_to_client()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->to_client(), output);
  }

  // optional .ts.PayInfo payinfo = 4;
  if (has_payinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->payinfo(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TransAmtAns::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .ts.ServiceHead head = 1;
  if (has_head()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->head(), target);
  }

  // optional .ts.ClientInfo from_client = 2;
  if (has_from_client()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->from_client(), target);
  }

  // optional .ts.ClientInfo to_client = 3;
  if (has_to_client()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->to_client(), target);
  }

  // optional .ts.PayInfo payinfo = 4;
  if (has_payinfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->payinfo(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TransAmtAns::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ts.ServiceHead head = 1;
    if (has_head()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->head());
    }

    // optional .ts.ClientInfo from_client = 2;
    if (has_from_client()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->from_client());
    }

    // optional .ts.ClientInfo to_client = 3;
    if (has_to_client()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->to_client());
    }

    // optional .ts.PayInfo payinfo = 4;
    if (has_payinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->payinfo());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransAmtAns::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TransAmtAns* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TransAmtAns*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TransAmtAns::MergeFrom(const TransAmtAns& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_head()) {
      mutable_head()->::ts::ServiceHead::MergeFrom(from.head());
    }
    if (from.has_from_client()) {
      mutable_from_client()->::ts::ClientInfo::MergeFrom(from.from_client());
    }
    if (from.has_to_client()) {
      mutable_to_client()->::ts::ClientInfo::MergeFrom(from.to_client());
    }
    if (from.has_payinfo()) {
      mutable_payinfo()->::ts::PayInfo::MergeFrom(from.payinfo());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TransAmtAns::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TransAmtAns::CopyFrom(const TransAmtAns& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransAmtAns::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_head()) {
    if (!this->head().IsInitialized()) return false;
  }
  if (has_from_client()) {
    if (!this->from_client().IsInitialized()) return false;
  }
  if (has_to_client()) {
    if (!this->to_client().IsInitialized()) return false;
  }
  if (has_payinfo()) {
    if (!this->payinfo().IsInitialized()) return false;
  }
  return true;
}

void TransAmtAns::Swap(TransAmtAns* other) {
  if (other != this) {
    std::swap(head_, other->head_);
    std::swap(from_client_, other->from_client_);
    std::swap(to_client_, other->to_client_);
    std::swap(payinfo_, other->payinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TransAmtAns::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TransAmtAns_descriptor_;
  metadata.reflection = TransAmtAns_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ts

// @@protoc_insertion_point(global_scope)
